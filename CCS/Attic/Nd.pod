##======================================================================
## Header Administrivia
##======================================================================
=pod

=head1 NAME

PDL::CCS::Nd - N-dimensional sparse pseudo-PDL

=head1 SYNOPSIS

 use PDL::CCS::Nd;

 ##---------------------------------------------------------------------
 ## ... stuff happens

=cut

##======================================================================
## Description
##======================================================================
=pod

=head1 DESCRIPTION

PDL::CCS::Nd provides an object-oriented implementation of
sparse N-dimensional vectors & matrices using a set of low-level
PDLs to encode non-missing values.
Currently, only a portion of the PDL API is implemented.

=cut

##======================================================================
## Globals
##======================================================================
=pod

=head1 GLOBALS

The following package-global variables are defined:

=cut

##--------------------------------------------------------------
## Globals: Block Sizes
=pod

=head2 Block Size Constants

 $BINOP_BLOCKSIZE_MIN = 1;
 $BINOP_BLOCKSIZE_MAX = 0;

Minimum (maximum) block size for block-wise incremental computation of binary operations.
Zero or undef indicates no minimum (maximum).

=cut

##--------------------------------------------------------------
## Globals: Object structure
=pod

=head2 Object Structure

PDL::CCS::Nd object are implemented as perl ARRAY-references.
For more intuitive access to object components, the following
package-global variables can be used as array indices to access
internal object structure:

=over 4

=item $PDIMS

Indexes a pdl(long,$NPdims) of physically indexed dimension sizes:

 $ccs->[$PDIMS]->at($pdim_i) == $dimSize_i

=item $VDIMS

Indexes a pdl(long,$NVdims) of "virtual" dimension sizes:

 $ccs->[$VDIMS]->at($vdim_i) == / -$vdimSize_i    if $vdim_i is a dummy dimension
                                \  $pdim_i        otherwise

The $VDIMS piddle is used for dimension-shuffling transformations such as xchg()
and reorder(), as well as for dummy().

=item $WHICH

Indexes a pdl(long,$NPdims,$Nnz) of the "physical indices" of all non-missing values
in the non-dummy dimensions of the corresponding dense matrix.
Vectors in $WHICH are guaranteed to be sorted in lexicographic order.
If your $missing value is zero, and if your qsortvec() function works,
it should be the case that:

 all( $ccs->[$WHICH] == $dense->whichND->qsortvec )

A "physically indexed dimension" is just a dimension
corresponding tp a single column of the $WHICH pdl, whereas a dummy dimension does
not correspond to any physically indexed dimension.

=item $VALS

Indexes a vector pdl($valType, $Nnz+1) of all values in the sparse matrix,
where $Nnz is the number of non-missing values in the sparse matrix.  Non-final
elements of the $VALS piddle are interpreted as the values of the corresponing
indices in the $WHICH piddle:

 all( $ccs->[$VALS]->slice("0:-2") == $dense->indexND($ccs->[$WHICH]) )

The final element of the $VALS piddle is referred to as "$missing", and
represents the value of all elements of the dense physical matrix whose
indices are not explicitly listed in the $WHICH piddle:

 all( $ccs->[$VALS]->slice("-1") == $dense->flat->index(which(!$dense)) )

=item $PTRS

Indexes an array of arrays containing Harwell-Boeing "pointer" piddle pairs
for the corresponding physically indexed dimension.
For a physically indexed dimension $d of size $N, $ccs-E<gt>[$PTRS][$d]
(if it exists) is a pair [$ptr,$ptrix] as returned by
PDL::CCS::Utils::ccs_encode_pointers($WHICH,$N), which are such that:

=over 4

=item $ptr

$ptr is a pdl(long,$N+1) containing the offsets in $ptrix corresponding
to the first non-missing value in the dimension $d.
For all $i, 0 E<lt>= $i E<lt> $N, $ptr($i) contains the
index of the first non-missing value (if any) from column $i of $dense(...,N,...)
encoded in the $WHICH piddle.  $ptr($N+1) contains the number of
physically indexed cells in the $WHICH piddle.

=item $ptrix

Is an index piddle into dim(1) of $WHICH rsp. dim(0) of $VALS whose key
positions correspond to the offsets listed in $ptr.  The point here is
that:

 $WHICH->dice_axis(1,$ptrix)

is guaranteed to be primarily sorted along the pointer dimension $d, and
stably sorted along all other dimensions, e.g. should be identical to:

 $WHICH->mv($d,0)->qsortvec->mv(0,$d)

=back


=item $FLAGS

Indexes a perl scalar containing some object-local flags.  See
L<"Object Flags"> for details.

=item $USER

Indexes the first unused position in the object array.
If you derive a class from PDL::CCS::Nd, you should use this
position to place any new object-local data.

=back

=cut


##--------------------------------------------------------------
## Globals: Object Flags
=pod

=head2 Object Flags

The following object-local constants are defined as bitmask flags:

=over 4

=item $CCSND_BAD_IS_MISSING

Bitmask of the "bad-is-missing" flag.  See the bad_is_missing() method.

=item $CCSND_NAN_IS_MISSING

Bitmask of the "NaN-is-missing" flag.  See the nan_is_missing() method.

=item $CCSND_INPLACE

Bitmask of the "inplace" flag.  See PDL::Core for details.

=item $FLAGS_DEFAULT

Default flags for new objects.

=back

=cut

##======================================================================
## Methods
##======================================================================
=pod

=head1 METHODS

=cut

##======================================================================
## Methods: Constructors etc.
##======================================================================
=pod

=head2 Constructors, etc.

=over 4

=item $class_or_obj-E<gt>newFromDense($dense,$missing,$flags)

=for sig

  Signature ($class_or_obj; dense(N1,...,NNdims); missing(); int flags)

Class method. Create and return a new PDL::CCS::Nd object from a dense N-dimensional
PDL $dense.  If specified, $missing is used as the value for "missing" elements,
and $flags are used to initialize the object-local flags.

$missing defaults to BAD if the bad flag of $dense is set, otherwise
$missing defaults to zero.


=item $ccs-E<gt>fromDense($dense,$missing,$flags)

=for sig

  Signature ($ccs; dense(N1,...,NNdims); missing(); int flags)

Object method.  Populate a sparse matrix object from a dense piddle $dense.
See newFromDense().


=item $class_or_obj-E<gt>newFromWhich($whichND,$nzvals,%options)

=for sig

  Signature ($class_or_obj; int whichND(Ndims,Nnz); nzvals(Nnz+1); %options)

Class method. Create and return a new PDL::CCS::Nd object from a set
of indices $whichND of non-missing elements in a (hypothetical) dense piddle
and a vector $nzvals of the corresponding values.  Known %options:

  sorted  => $bool,    ##-- if true, $whichND is assumed to be pre-sorted
  steal   => $bool,    ##-- if true, $whichND and $nzvals are used literally (implies 'sorted')
                       ##    + in this case, $nzvals should really be: $nzvals->append($missing)
  pdims   => $pdims,   ##-- physical dimension list; default guessed from $whichND (alias: 'dims')
  vdims   => $vdims,   ##-- virtual dims (default: sequence($nPhysDims)); alias: 'xdims'
  missing => $missing, ##-- default: BAD if $nzvals->badflag, 0 otherwise
  flags   => $flags    ##-- flags

=item $ccs-E<gt>fromWhich($whichND,$nzvals,%options)

Object method.  Guts for newFromWhich().


=item $a-E<gt>toccs($missing,$flags)

Wrapper for newFromDense().  Return a PDL::CCS::Nd object for any piddle or
perl scalar $a.
If $a is already a PDL::CCS::Nd object, just returns $a.
This method gets exported into the PDL namespace for ease of use.


=item $ccs = $ccs-E<gt>copy()

Full copy constructor.

=item $ccs2 = $ccs-E<gt>copyShallow()

Shallow copy constructor, used e.g. by dimension-shuffling transformations.
Copied components:

 $PDIMS, @$PTRS, @{$PTRS->[*]}, $FLAGS

Referenced components:

 $VDIMS, $WHICH, $VALS,  $PTRS->[*][*]


=item $ccs2 = $ccs1-E<gt>shadow(%args)

Flexible constructor for computed PDL::CCS::Nd objects.
Known %args:

  to    => $ccs2,    ##-- default: new
  pdims => $pdims2,  ##-- default: $pdims1->pdl  (alias: 'dims')
  vdims => $vdims2,  ##-- default: $vdims1->pdl  (alias: 'xdims')
  ptrs  => \@ptrs2,  ##-- default: []
  which => $which2,  ##-- default: undef
  vals  => $vals2,   ##-- default: undef
  flags => $flags,   ##-- default: $flags1

=back

=cut


##======================================================================
## Methods: Maintainence & Decoding
##======================================================================
=pod

=head2 Maintainence & Decoding

=over 4

=item $ccs = $ccs-E<gt>recode()

Recodes the PDL::CCS::Nd object, removing any missing values from its $VALS piddle.

=item $ccs = $ccs-E<gt>sortwhich()

Lexicographically sorts $ccs-E<gt>[$WHICH], altering $VALS accordingly.
Clears $PTRS.


=item $dense = $ccs-E<gt>decode()

=item $dense = $ccs-E<gt>decode($dense)

Decode a PDL::CCS::Nd object to a dense piddle.
Dummy dimensions in $ccs should be created as dummy dimensions in $dense.

=item $dense = $a-E<gt>todense()

Ensures that $a is not a PDL::CCS::Nd by wrapping decode().
For PDLs or perl scalars, just returns $a.

=back

=cut

##======================================================================
## Methods: PDL API: Basic Properties
##======================================================================
=pod

=head2 PDL API: Basic Properties

The following basic PDL API methods are implemented and/or wrapped
for PDL::CCS::Nd objects:

=over 4

=item Type Checking & Conversion

type, convert, byte, short, ushort, long, double

Type-checking and conversion routines are passed on to the $VALS sub-piddle.

=item Dimension Access

dims, dim, getdim, ndims, getndims, nelem, isnull, isempty

Note that nelem() returns the number of hypothetically addressable
cells -- the number of cells in the corresponding dense matrix, rather
than the number of non-missing elements actually stored.

=item Inplace Operations

set_inplace($bool), is_inplace(), inplace()

=item Dataflow

sever

=item Bad Value Handling

setnantobad, setbadtonan, setbadtoval, setvaltobad

See also the bad_is_missing() and nan_is_missing() methods, below.

=back

=cut

##======================================================================
## Methods: PDL API: Dimension Shuffling
##======================================================================
=pod

=head2 PDL API: Dimension Shuffling

The following dimension-shuffling methods are supported,
and should be compatible to their PDL counterparts:

=over 4

=item dummy($vdimi)

=item dummy($vdimi, $size)

Insert a "virtual" dummy dimension of size $size at dimension index $vdimi.


=item reorder(@vdim_list)

Reorder dimensions according to @vdim_list.

=item xchg($vdim1,$vdim2)

Exchange two dimensions.

=item mv($vdimFrom, $vdimTo)

Move a dimension to another position, shoving remaining
dimensions out of the way to make room.

=item transpose()

Always copies, unlike xchg().  Also unlike xchg(), works for 1d row-vectors.

=back

=cut

##======================================================================
## Methods: PDL API: Indexing
##======================================================================
=pod

=head2 PDL API: Indexing

=over 4

=item indexNDi($ndi)

=for sig

  Signature: ($ccs; int ndi(NVdims,Nind); int [o]nzi(Nind))

Guts for indexing methods.  Given an N-dimensional index piddle $ndi, return
a 1d index vector into $VALS for the corresponding values.
Missing values are returned in $nzi as $Nnz.

Uses PDL::VectorValues::vsearchvec() internally, so expect O(Ndims * log(Nnz)) complexity.
Although the theoretical complexity is tough to beat, this method could be
made much faster in the general (read "sparse") case by an intelligent use of $PTRS if
and when available.

=item indexND($ndi)

=item index2d($xi,$yi)

Should be mostly compatible to the PDL functions of the same names,
but without any boundary handling.

=item index($flati)

Implicitly flattens the source pdl.
This ought to be fixed.

=item dice_axis($axis_v, $axisi)

Should be compatible with the PDL function of the same name.
Returns a new PDL::CCS::Nd object which should participate
in dataflow.

=item n2oned($ndi)

Returns a 1d pseudo-index, used for implementation of which(), etc.

=item whichND()

Should behave mostly like the PDL function of the same name.

Just returns the literal $WHICH piddle if possible: beware of dataflow!
Indices are NOT guaranteed to be returned in any surface-logical order,
although physically indexed dimensions should be sorted in physical-lexicographic
order.

=item whichVals()

Returns $VALS indexed to correspond to the indices returned by whichND().
The only reason to use whichND() and whichVals() rather than $WHICH and $VALS
would be a need for physical representations of dummy dimension indices: try
to avoid it if you can.

=item which()

As for the builtin PDL function.


=item at(@index)

Return a perl scalar corresponding to the Nd index @index.

=item set(@index, $value)

Set a non-missing value at index @index to $value.
barf()s if @index points to a missing value.

=back

=cut

##======================================================================
## Methods: Operations: Ufuncs
##======================================================================
=pod

=head2 Ufuncs

The following functions from PDL::Ufunc are supported:

 prodover
 prod
 dprodover
 dprod
 sumover
 sum
 dsumover
 dsum
 andover
 orover
 bandover
 borover
 maximum
 max
 minimum
 min
 nbadover
 nbad
 ngoodover
 ngood
 nnz
 any
 all

=cut

##======================================================================
## Methods: Operations: Unary
##======================================================================
=pod

=head2 Unary Operations

The following unary operations are supported:

 bitnot
 sqrt
 abs
 sin
 cos
 not
 exp
 log
 log10

Note that any pointwise unary operation can be performed directly on
the $VALS piddle.  You can wrap such an operation MY_UNARY_OP on piddles
into a PDL::CCS::Nd method using the idiom:

 package PDL::CCS::Nd;
 *MY_UNARY_OP = _unary_op('MY_UNARY_OP', PDL->can('MY_UNARY_OP'));

=cut



##======================================================================
## Methods: Low-Level Object Access
##======================================================================
=pod

=head2 Low-Level Object Access

The following methods provide low-level access to
PDL::CCS::Nd object structure:

=over 4

=item allmissing()

True if no non-missing values are stored


=item pdims()

Returns the $PDIMS piddle.  See L<"Object Structure">, above.

=item vdims()

Returns the $VDIMS piddle.  See L<"Object Structure">, above.


=item nelem_p()

Returns the number of physically addressable elements.

=item nelem_v()

Returns the number of virtually addressable elements.
Alias for nelem().


=item _ccs_nvperp()

Returns number of virtually addressable elements per physically
adressable element, which should be a positive integer.


=item nstored_p()

Returns actual number of physically addressed stored elements
(aka $Nnz aka $WHIH-E<gt>dim(1)).

=item nstored_v()

Returns actual number of physically+virtually addressed stored elements.


=item nmissing_p()

Returns number of physically addressable elements minus the number of
physically stored elements.

=item nmissing_v()

Returns number of physically+virtually addressable elements minus the number of
physically+virtually stored elements.


=item missing()

=item missing($missing)

Get/set the value to use for missing elements.
Returns the (new) value for $missing.


=item _whichND()

=item _whichND($whichND)

Get/set the underlying $WHICH piddle.


=item _vals()

=item _vals($storedvals)

Get/set the underlying $VALS piddle.


=item ptr($pdimi)

Get a pointer pair for a physically indexed dimension $pdimi.
Uses cached piddles in $PTRS if present, computes & caches otherwise.

$pdimi defaults to zero.  If $pdimi is zero, then it should hold that:

 all( $pi2nzi==sequence($ccs->nstored_p) )

=item getptr($pdimi)

Guts for ptr().  Does not check $PTRS and does not cache anything.


=item flags()

=item flags($flags)

Get/set object-local $FLAGS.


=item bad_is_missing()

=item bad_is_missing($bool)

Get/set the value of the object-local "bad-is-missing" flag.
If this flag is set, BAD values in $VALS are considered "missing",
regardless of the current value of $missing.


=item nan_is_missing()

=item nan_is_missing($bool)

Get/set the value of the object-local "NaN-is-missing" flag.
If this flag is set, NaN (and +inf, -inf) values in $VALS are considered "missing",
regardless of the current value of $missing.

=back

=cut
