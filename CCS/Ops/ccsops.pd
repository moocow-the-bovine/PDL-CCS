##-*- Mode: CPerl -*-

##======================================================================
## Header Administrivia
##======================================================================

use PDL::VectorValued::Dev;
require "../Version.pm";
our $VERSION = $PDL::CCS::VERSION;
pp_setversion($VERSION);

##------------------------------------------------------
## pm headers
pp_addpm({At=>'Top'},<<'EOPM');

#use PDL::CCS::Version;
use strict;

=pod

=head1 NAME

PDL::CCS::Ops - Low-level binary operations for compressed storage sparse PDLs

=head1 SYNOPSIS

 use PDL;
 use PDL::CCS::Utils;

 ##---------------------------------------------------------------------
 ## ... stuff happens

=cut

EOPM
## /pm additions
##------------------------------------------------------

##------------------------------------------------------
## Exports: None
#pp_export_nothing();

##------------------------------------------------------
## Includes / defines
pp_addhdr(<<'EOH');
EOH


##======================================================================
## C Utilities
##======================================================================
# (none)

##======================================================================
## PDL::PP Wrappers
##======================================================================


##======================================================================
## Operations: Binary: GENERIC
##======================================================================

vvpp_def
  ('ccs_binop_align_block',
   Pars => ("\n    "
	    .join("\n    ",
		  'int ixa(Ndims,NnzA); int ixb(Ndims,NnzB); int    istate(State);',
		  'int [o]nzai(NnzC);   int [o]nzbi(NnzC);   int [o]ostate(State);',
		  '')),
   Code =>
(q(
 long sizeNnzA=$SIZE(NnzA), sizeNnzB=$SIZE(NnzB), sizeNnzC=$SIZE(NnzC);
 long nnzai=0, nnzbi=0,nnzbi0, nnzci=0, nnzai_nxt=0,nnzbi_nxt=0,nnzci_nxt=0;
 int cmpme1,cmpme2, cmpval=0;
 //
 //-- initialize: parse istate() [ nnzai,nnzai_nxt, nnzbi,nnzbi_nxt, nnzci,nnzci_nxt, cmpval ]
 if ($SIZE(State) >= 7) {
   nnzai     = $istate(State=>0);
   nnzai_nxt = $istate(State=>1);
   nnzbi     = $istate(State=>2);
   nnzbi_nxt = $istate(State=>3);
   nnzci     = $istate(State=>4);
   nnzci_nxt = $istate(State=>5);
   cmpval    = $istate(State=>6);
 }
 //
 //-- main loop: start at current nnzai,nnzbi,nnzci
 for ( ; nnzai<sizeNnzA && nnzbi<sizeNnzB && nnzci_nxt<sizeNnzC; ) {
   //
   //-- dispatch on cached cmpval for current index-runs (nnzai..nnzai_nxt),(nnzbi..nnzbi_nxt)
   if (cmpval < 0) {
     //-- CASE ixa(,ai) < ixb(,bi) : INSERT ( ixa(,ai) => (ixa(,ai) . -1) ); INCR(ai);
     for ( ; nnzai<nnzai_nxt; nnzai++, nnzci++) {
       $nzai(NnzC=>nnzci) = nnzai;
       $nzbi(NnzC=>nnzci) = -1;
     }
     //-- increment ai: detect next run-length
     for (nnzai_nxt=nnzai+1; nnzai_nxt<sizeNnzA; nnzai_nxt++) {
       $CMPVEC('$ixa(NnzA=>nnzai)','$ixa(NnzA=>nnzai_nxt)','Ndims','cmpval',var1=>'cmpme1',var2=>'cmpme2');
       if (cmpval != 0) break;
     }
   }
   else if (cmpval > 0) {
     //-- CASE ixa(,ai) > ixb(,bi) : INSERT ( ixb(,bi) => (-1 . ixb(,bi)) ); INCR(bi);
     for ( ; nnzbi<nnzbi_nxt; nnzbi++, nnzci++) {
       $nzai(NnzC=>nnzci) = -1;
       $nzbi(NnzC=>nnzci) = nnzbi;
     }
     //-- increment bi: detect next run-length
     for (nnzbi_nxt=nnzbi+1; nnzbi_nxt<sizeNnzB; nnzbi_nxt++) {
       $CMPVEC('$ixb(NnzB=>nnzbi)','$ixb(NnzB=>nnzbi_nxt)','Ndims','cmpval',var1=>'cmpme1',var2=>'cmpme2');
       if (cmpval != 0) break;
     }
   }
   else {
     //-- CASE ixa(,ai) == ixb(,bi) : INSERT ( ixa(,ai) => (ixa(,ai) . ixb(,bi)) ); INCR(ai); INCR(bi);
     for (nnzbi0=nnzbi; nnzai<nnzai_nxt; nnzai++) {
       for (nnzbi=nnzbi0; nnzbi<nnzbi_nxt; nnzbi++, nnzci++) {
	 $nzai(NnzC=>nnzci) = nnzai;
	 $nzbi(NnzC=>nnzci) = nnzbi;
       }
     }
     //-- increment ai,bi: detect next run-lengths
     for (nnzai_nxt=nnzai+1; nnzai_nxt<sizeNnzA; nnzai_nxt++) {
       $CMPVEC('$ixa(NnzA=>nnzai)','$ixa(NnzA=>nnzai_nxt)','Ndims','cmpval',var1=>'cmpme1',var2=>'cmpme2');
       if (cmpval != 0) break;
     }
     for (nnzbi_nxt=nnzbi+1; nnzbi_nxt<sizeNnzB; nnzbi_nxt++) {
       $CMPVEC('$ixb(NnzB=>nnzbi)','$ixb(NnzB=>nnzbi_nxt)','Ndims','cmpval',var1=>'cmpme1',var2=>'cmpme2');
       if (cmpval != 0) break;
     }
   }
   //
   //-- compare current index-run values
   $CMPVEC('$ixa(NnzA=>nnzai)','$ixb(NnzB=>nnzbi)','Ndims','cmpval',var1=>'cmpme1',var2=>'cmpme2');
   if      (cmpval < 0) { nnzci_nxt = nnzci + (nnzai_nxt-nnzai); }
   else if (cmpval > 0) { nnzci_nxt = nnzci + (nnzbi_nxt-nnzbi); }
   else                 { nnzci_nxt = nnzci + (nnzai_nxt-nnzai)*(nnzbi_nxt-nnzbi); }
 } //-- end main loop
 //
 //-- gobble leftovers
 if (nnzci<sizeNnzC) {
   if (nnzbi >= sizeNnzB) {
     for ( ; nnzai<sizeNnzA && nnzci<sizeNnzC; nnzai++,nnzci++) {
       $nzai(NnzC=>nnzci) = nnzai;
       $nzbi(NnzC=>nnzci) = -1;
     }
     nnzci_nxt = nnzci;
     cmpval    = -1;
   }
   if (nnzai >= sizeNnzA) {
     for ( ; nnzbi<sizeNnzB && nnzci<sizeNnzC; nnzbi++,nnzci++) {
       $nzai(NnzC=>nnzci) = -1;
       $nzbi(NnzC=>nnzci) = nnzbi;
     }
     nnzci_nxt = nnzci;
     cmpval    = 1;
   }
 }
 //
 //-- save state
 if ($SIZE(State) >= 7) {
   $ostate(State=>0) = nnzai;
   $ostate(State=>1) = nnzai_nxt;
   $ostate(State=>2) = nnzbi;
   $ostate(State=>3) = nnzbi_nxt;
   $ostate(State=>4) = nnzci;
   $ostate(State=>5) = nnzci_nxt;
   $ostate(State=>6) = cmpval;
 }
)),
  Doc =>
(q(
TODO: update docs

Partially aligns a pair lexicographically sorted index-vector lists C<$ixa()> and C<$ixb()>,
e.g. for block-wise incremental computation of binary operations over sparse index-encoded PDLs.

On return, the vectors C<$nzai> and C<$nzbi> hold indices into C<NnzA> and C<NnzB>
respectively, and are constructed such that:

 ($ixa(,$nzai) <= $ixb(,$nzbi)) whenever ($nzai >= 0 && $nzbi >= 0)

Negative values in the output index vectors C<$nzai> and C<$nzbi> indicate
unalignable key vectors in the alternative index list.

 ($nzai(i) < 0) implies there is no j such that ($ixa(,i) == $ixb(,j))

At most C<NnzC> alignments are performed, and alignment ceases
as soon as any of the PDLs C<$ixa()>, C<$ixb()>, C<$nzai()>, or C<$nzbi()>
has been exhausted.

The output parameters C<$nzai_nxt()>, C<$nzbi_nxt()>, and C<$nzci_nxt()>
return the first unaligned index of the respective PDL.
)),

 ); ##--/ccs_binop_align_block


##======================================================================
## IDEA:
##  ccs_binop_${OP}(int    ixa(NdimsA,NnzA),    nza(NnzA),    missinga(),
##                  int    ixb(NdimsB,NnzB),    nzb(NnzB),    missingb(),
##                  int [o]ixc(NdimsC,NnzC), [o]nzc(NnzC), [o]missingc())
##  + where:
##    - NdimsA==NdimsB==NdimsC  ##-- simple case: no (pseudo-)threading
##    - NnzC <= NnzA+NnzB       ##-- add auto-trimming in PMCode
##    - ixa() and ixb() are both sorted
##
##  + idea: basic algorithm
##    - traverse ixa(),ixb() in parallel (as for vv_union() & friends)
##    - dispatch at each position:
##      ~ CASE ixa(,ai) == ixb(,bi) : INSERT ( ixa(,ai) => ixa(,ai)   ${OP} ixb(,bi)   ); ai++; bi++;
##      ~ CASE ixa(,ai) <  ixb(,bi) : INSERT ( ixa(,ai) => ixa(,ai)   ${OP} missingb() ); ai++;
##      ~ CASE ixa(,ai) >  ixb(,bi) : INSERT ( ixb(,bi) => missinga() ${OP} ixb(,bi)   );       bi++;
##    - DO auto-detect "missingOut" values, e.g. add 'tmp_isgood' check
##
##  + extension: pseudo-threading
##    - idea: allow (NdimsA != NdimsB)
##      ~ generalize to highest order: set NdimsC = max(NdimsA,NdimsB)
##      ~ also allow PMCode to dispatch s.t. (NdimsB <= NdimsA)
##      ~ then, vector comparison is: ixa(0..(NdimsB-1),ai) <=> ixb(,bi)
##        * requires home-grown CMPVEC or extension of PDL::VectorValued $CMPVEC() macro
##        * this allows ixb() to thread over INITIAL dimensions (a la PDL threading)
##        * still doesn't generalize to VECTORS ~ dimension-mismatches where e.g. NdimsB(dimi)==1
##      ~ also wreaks havoc with the case-based increment strategy above:
##        * if (NdimsB < NdimsA), we might well have multiple matches on a single ixb(,bi)
##        * third insertion case may induce a dense matrix, b/c requires implicit iteration:
##             { insert( ixb(,bi) => missinga() ${OP} ixb(,bi) ); bi++ }
##          + this won't cut the sparse butter though, since ixb(,bi) ~= $ixb(,bi).cat_{di=1}^{NdimsA-NdimsB)(seq(di))
##      ~ maybe abstract "alignment" code (ixa(,ai)<=>ixb(,bi)) to its own function
##        and do the rest in perl?
##        * ccs_binop_align( ixa(), ixb(), int [o]ai(NnzC), int [o]bi(NnC) )
##          - here, we can use a constant (say, -1 or BAD) to indicate "no-match", e.g.
##              ai->isbad()   iff.   ixa(,ai) <  ixb(,bi)
##              bi->isbad()   iff.   ixa(,ai) >  ixb(,bi)
##          - maybe 'annihilator assumption' from compat vector-ops can save us ...

##======================================================================
## Footer Administrivia
##======================================================================

##------------------------------------------------------
## pm additions: footer
pp_addpm(<<'EOPM');

##---------------------------------------------------------------------
=pod

=head1 ACKNOWLEDGEMENTS

Perl by Larry Wall.

PDL by Karl Glazebrook, Tuomas J. Lukka, Christian Soeller, and others.

=cut

##----------------------------------------------------------------------
=pod

=head1 KNOWN BUGS

No support for (pseudo)-threading.

=cut


##---------------------------------------------------------------------
=pod

=head1 AUTHOR

Bryan Jurish E<lt>moocow@ling.uni-potsdam.deE<gt>

=head2 Copyright Policy

All other parts Copyright (C) 2007, Bryan Jurish. All rights reserved.

This package is free software, and entirely without warranty.
You may redistribute it and/or modify it under the same terms
as Perl itself.

=head1 SEE ALSO

perl(1), PDL(3perl)

=cut

EOPM


# Always make sure that you finish your PP declarations with
# pp_done
pp_done();
##----------------------------------------------------------------------
