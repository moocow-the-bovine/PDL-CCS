##-*- Mode: CPerl -*-

##======================================================================
## Header Administrivia
##======================================================================

use PDL::VectorValued::Dev;
require "../Version.pm";
our $VERSION = $PDL::CCS::VERSION;
pp_setversion($VERSION);

##------------------------------------------------------
## pm headers
pp_addpm({At=>'Top'},<<'EOPM');

#use PDL::CCS::Version;
use strict;

=pod

=head1 NAME

PDL::CCS::Ops - Low-level binary operations for compressed storage sparse PDLs

=head1 SYNOPSIS

 use PDL;
 use PDL::CCS::Utils;

 ##---------------------------------------------------------------------
 ## ... stuff happens

=cut

EOPM
## /pm additions
##------------------------------------------------------

##------------------------------------------------------
## Exports: None
#pp_export_nothing();

##------------------------------------------------------
## Includes / defines
pp_addhdr(<<'EOH');
EOH


##======================================================================
## C Utilities
##======================================================================
# (none)

##======================================================================
## PDL::PP Wrappers
##======================================================================


##======================================================================
## Operations: Binary
##======================================================================

##--------------------------------------------------------------
## Operations: Binary: plus
vvpp_def
  ('ccs_binop_plus',
   Pars => ("\n    "
	    .join("\n    ",
		  'int    ixa(Ndims,NnzA);    nza(NnzA);    missinga();',
		  'int    ixb(Ndims,NnzB);    nzb(NnzB);    missingb();',
		  'int [o]ixc(Ndims,NnzC); [o]nzc(NnzC); [o]missingc(); int [o]nnzc();',
		  '')),
   PMCode =>
(q(
 sub PDL::ccs_binop_plus {
   my ($ixa,$nza,$za, $ixb,$nzb,$zb, $ixc,$nzc,$zc,$nnzc_out) = @_;
   ##
   ##-- init: get dimensions
   my ($ndimsA,$nnzA,@tdimsA) = $ixa->dims;
   my ($ndimsB,$nnzB,@tdimsB) = $ixb->dims;
   barf("PDL::ccs_binop_plus(): no support for NdimsA!=NdimsB ($ndimsA!=$ndimsB)") if ($ndimsA != $ndimsB);
   barf("PDL::ccs_binop_plus(): threaded dimension mismatch")
     if ($#tdimsA != $#tdimsB || grep {$tdimsA[$_] != $tdimsB[$_]} (0..$#tdimsA));
   my ($ndimsC,$nnzC,@tdimsC);
   if (defined($ixc)) {
     ($ndimsC,$nnzC,@tdimsC) = $ixc->dims;
   } else {
     $ndimsC=$ndimsA;
   }
   ($nnzC,@tdimsC) = $nzc->dims if (!defined($nnzC) && defined($nzc) && !$nzc->isempty);
   if (!defined($nnzC)) {
     $nnzC   = $nnzA+$nnzB;
     @tdimsC = @tdimsA;
   } else {
     ##-- sanity check
     barf("PDL::ccs_binop_plus(): no support for NdimsA!=NdimsC ($ndimsA!=$ndimsC)") if ($ndimsA != $ndimsC);
     barf("PDL::ccs_binop_plus(): threaded dimension mismatch")
       if ($#tdimsA != $#tdimsC || grep {$tdimsA[$_] != $tdimsC[$_]} (0..$#tdimsA));
   }
   ##
   ##-- allocate
   $ixc      = PDL->zeroes(PDL::long(), $ndimsC,$nnzC,@tdimsC) if (!defined($ixc));
   $nzc      = PDL->zeroes($nza->type, $nnzC,@tdimsC)          if (!defined($nzc));
   $zc       = PDL->zeroes($nzc->type, 1)                      if (!defined($zc));
   $nnzc_out = PDL->pdl(PDL::long(), 0)                        if (!defined($nnzc_out));
   ##
   ##-- internal call
   &PDL::_ccs_binop_plus_int($ixa,$nza,$za, $ixb,$nzb,$zb, $ixc,$nzc,$zc, $nnzc_out);
   ##
   ##-- auto-trim
   my $trimto = $nnzc_out->max-1;
   $ixc = $ixc->slice(",0:$trimto");
   $nzc = $nzc->slice("0:$trimto");
   return wantarray ? ($ixc,$nzc,$zc,$nnzc_out) : $nzc;
 }
)),
   Code =>
(q(
 long nnzai, nnzbi, nnzci=0;
 long sizeNnzA=$SIZE(NnzA), sizeNnzB=$SIZE(NnzB), sizeNnzC=$SIZE(NnzC);
 int ixaval,ixbval,cmpval;
 $GENERIC() zvala, zvalb, zvalc; //-- missing values
 $GENERIC() nzvalc;              //-- temporary
 //
 //-- init
 zvala = $missinga();
 zvalb = $missingb();
 zvalc = zvala + zvalb;
 //
 //-- main loop
 for ( nnzai=0,nnzbi=0; nnzai<sizeNnzA && nnzbi<sizeNnzB && nnzci<sizeNnzC; ) {
   $CMPVEC('$ixa(NnzA=>nnzai)','$ixb(NnzB=>nnzbi)','Ndims','cmpval',var1=>'ixaval',var2=>'ixbval');
   if (cmpval < 0) {
     //-- CASE ixa(,ai) <  ixb(,bi) : INSERT ( ixa(,ai) => ixa(,ai)   ${OP} missingb() ); ai++;
     nzvalc = $nza(NnzA=>nnzai) + zvalb;
     if (nzvalc != zvalc) {
       loop (Ndims) %{ $ixc(NnzC=>nnzci) = $ixa(NnzA=>nnzai); %}
       $nzc(NnzC=>nnzci) = nzvalc;
       nnzci++;
     }
     nnzai++;
   }
   else if (cmpval > 0) {
     //-- CASE ixa(,ai) >  ixb(,bi) : INSERT ( ixb(,bi) => missinga() ${OP} ixb(,bi)   );       bi++;
     nzvalc = zvala + $nzb(NnzB=>nnzbi);
     if (nzvalc != zvalc) {
       loop (Ndims) %{ $ixc(NnzC=>nnzci) = $ixb(NnzB=>nnzbi); %}
       $nzc(NnzC=>nnzci) = nzvalc;
       nnzci++;
     }
     nnzbi++;
   }
   else { /*(cmpval == 0)*/
     //-- CASE ixa(,ai) == ixb(,bi) : INSERT ( ixa(,ai) => ixa(,ai)   ${OP} ixb(,bi)   ); ai++; bi++;
     nzvalc = $nza(NnzA=>nnzai) + $nzb(NnzB=>nnzbi);
     if (nzvalc != zvalc) {
       loop (Ndims) %{ $ixc(NnzC=>nnzci) = $ixa(NnzA=>nnzai); %}
       $nzc(NnzC=>nnzci) = nzvalc;
       nnzci++;
     }
     nnzai++;
     nnzbi++;
   }
 }
 //
 //-- gobble remaining values from a()
 for ( ; nnzai<sizeNnzA && nnzci<sizeNnzC; nnzai++) {
   //-- CASE ixa(,ai) <  ixb(,bi) : INSERT ( ixa(,ai) => ixa(,ai)   ${OP} missingb() ); ai++;
   nzvalc = $nza(NnzA=>nnzai) + zvalb;
   if (nzvalc != zvalc) {
     loop (Ndims) %{ $ixc(NnzC=>nnzci) = $ixa(NnzA=>nnzai); %}
     $nzc(NnzC=>nnzci) = nzvalc;
     nnzci++;
   }
 }
 //
 //-- gobble remaining values from b()
 for ( ; nnzbi<sizeNnzB && nnzci<sizeNnzC; nnzbi++) {
   //-- CASE ixa(,ai) >  ixb(,bi) : INSERT ( ixb(,bi) => missinga() ${OP} ixb(,bi)   );       bi++;
   nzvalc = zvala + $nzb(NnzB=>nnzbi);
   if (nzvalc != zvalc) {
     loop (Ndims) %{ $ixc(NnzC=>nnzci) = $ixb(NnzB=>nnzbi); %}
     $nzc(NnzC=>nnzci) = nzvalc;
     nnzci++;
   }
 }
 //
 //-- set remaining output values
 $nnzc()     = nnzci;
 $missingc() = zvalc;
 for ( ; nnzci<sizeNnzC; nnzci++) {
   loop (Ndims) %{ $ixc(NnzC=>nnzci) = -1; %}
   $nzc(NnzC=>nnzci) = zvalc;
 }
)),
  ); ##-- /ccs_binop_plus

## IDEA:
##  ccs_binop_${OP}(int    ixa(NdimsA,NnzA),    nza(NnzA),    missinga(),
##                  int    ixb(NdimsB,NnzB),    nzb(NnzB),    missingb(),
##                  int [o]ixc(NdimsC,NnzC), [o]nzc(NnzC), [o]missingc())
##  + where:
##    - NdimsA==NdimsB==NdimsC  ##-- simple case: no (pseudo-)threading
##    - NnzC <= NnzA+NnzB       ##-- add auto-trimming in PMCode
##    - ixa() and ixb() are both sorted
##
##  + idea: basic algorithm
##    - traverse ixa(),ixb() in parallel (as for vv_union() & friends)
##    - dispatch at each position:
##      ~ CASE ixa(,ai) == ixb(,bi) : INSERT ( ixa(,ai) => ixa(,ai)   ${OP} ixb(,bi)   ); ai++; bi++;
##      ~ CASE ixa(,ai) <  ixb(,bi) : INSERT ( ixa(,ai) => ixa(,ai)   ${OP} missingb() ); ai++;
##      ~ CASE ixa(,ai) >  ixb(,bi) : INSERT ( ixb(,bi) => missinga() ${OP} ixb(,bi)   );       bi++;
##    - DO auto-detect "missingOut" values, e.g. add 'tmp_isgood' check
##
##  + extension: pseudo-threading
##    - idea: allow (NdimsA != NdimsB)
##      ~ generalize to highest order: set NdimsC = max(NdimsA,NdimsB)
##      ~ also allow PMCode to dispatch s.t. (NdimsB <= NdimsA)
##      ~ then, vector comparison is: ixa(0..(NdimsB-1),ai) <=> ixb(,bi)
##        * requires home-grown CMPVEC or extension of PDL::VectorValued $CMPVEC() macro
##        * this allows ixb() to thread over INITIAL dimensions (a la PDL threading)
##        * still doesn't generalize to VECTORS ~ dimension-mismatches where e.g. NdimsB(dimi)==1
##      ~ also wreaks havoc with the case-based increment strategy above:
##        * if (NdimsB < NdimsA), we might well have multiple matches on a single ixb(,bi)
##        * third insertion case may induce a dense matrix, b/c requires implicit iteration:
##             { insert( ixb(,bi) => missinga() ${OP} ixb(,bi) ); bi++ }
##          + this won't cut the sparse butter though, since ixb(,bi) ~= $ixb(,bi).cat_{di=1}^{NdimsA-NdimsB)(seq(di))
##      ~ maybe abstract "alignment" code (ixa(,ai)<=>ixb(,bi)) to its own function
##        and do the rest in perl?
##        * ccs_binop_align( ixa(), ixb(), int [o]ai(NnzC), int [o]bi(NnC) )
##          - here, we can use a constant (say, -1 or BAD) to indicate "no-match", e.g.
##              ai->isbad()   iff.   ixa(,ai) <  ixb(,bi)
##              bi->isbad()   iff.   ixa(,ai) >  ixb(,bi)
##          - maybe 'annihilator assumption' from compat vector-ops can save us ...

##======================================================================
## Footer Administrivia
##======================================================================

##------------------------------------------------------
## pm additions: footer
pp_addpm(<<'EOPM');

##---------------------------------------------------------------------
=pod

=head1 ACKNOWLEDGEMENTS

Perl by Larry Wall.

PDL by Karl Glazebrook, Tuomas J. Lukka, Christian Soeller, and others.

=cut

##----------------------------------------------------------------------
=pod

=head1 KNOWN BUGS

Probably many.

=cut


##---------------------------------------------------------------------
=pod

=head1 AUTHOR

Bryan Jurish E<lt>moocow@ling.uni-potsdam.deE<gt>

=head2 Copyright Policy

Copyright (C) 2007, Bryan Jurish. All rights reserved.

This package is free software, and entirely without warranty.
You may redistribute it and/or modify it under the same terms
as Perl itself.

=head1 SEE ALSO

perl(1), PDL(3perl)

=cut

EOPM


# Always make sure that you finish your PP declarations with
# pp_done
pp_done();
##----------------------------------------------------------------------
