##-*- Mode: CPerl -*-

##======================================================================
## Header Administrivia
##======================================================================

use PDL::VectorValued::Dev;
require "../Version.pm";
our $VERSION = $PDL::CCS::VERSION;
pp_setversion($VERSION);

##------------------------------------------------------
## pm headers
pp_addpm({At=>'Top'},<<'EOPM');

#use PDL::CCS::Version;
use strict;

=pod

=head1 NAME

PDL::CCS::Ops - Low-level binary operations for compressed storage sparse PDLs

=head1 SYNOPSIS

 use PDL;
 use PDL::CCS::Utils;

 ##---------------------------------------------------------------------
 ## ... stuff happens

=cut

EOPM
## /pm additions
##------------------------------------------------------

##------------------------------------------------------
## Exports: None
#pp_export_nothing();

##------------------------------------------------------
## Includes / defines
pp_addhdr(<<'EOH');
EOH


##======================================================================
## C Utilities
##======================================================================
# (none)

##======================================================================
## PDL::PP Wrappers
##======================================================================


##======================================================================
## Operations: Binary: GENERIC
##======================================================================

vvpp_def
  ('ccs_binop_align_block',
   Pars => ("\n    "
	    .join("\n    ",
		  'int ixa(Ndims,NnzA); int ixb(Ndims,NnzB);',
		  'int [o]nzai(NnzC);   int [o]nzbi(NnzC);',
		  'int [o]nzai_nxt();   int [o]nzbi_nxt();   int [o]nzci_nxt();',
		  '')),
   Code =>
(q(
 long nnzai, nnzbi, nnzci=0;
 long sizeNnzA=$SIZE(NnzA), sizeNnzB=$SIZE(NnzB), sizeNnzC=$SIZE(NnzC);
 int ixaval,ixbval,cmpval;
 //
 //-- main loop
 for ( nnzai=0,nnzbi=0; nnzai<sizeNnzA && nnzbi<sizeNnzB && nnzci<sizeNnzC; nnzci++ ) {
   $CMPVEC('$ixa(NnzA=>nnzai)','$ixb(NnzB=>nnzbi)','Ndims','cmpval',var1=>'ixaval',var2=>'ixbval');
   if (cmpval < 0) {
     //-- CASE ixa(,ai) <  ixb(,bi) : INSERT ( ixa(,ai) => (ixa(,ai) . -1) ); ai++;
     $nzai(NnzC=>nnzci) = nnzai;
     $nzbi(NnzC=>nnzci) = -1;
     nnzai++;
   }
   else if (cmpval > 0) {
     //-- CASE ixa(,ai) >  ixb(,bi) : INSERT ( ixb(,bi) => (-1 . ixb(,bi))  ); bi++;
     $nzai(NnzC=>nnzci) = -1;
     $nzbi(NnzC=>nnzci) = nnzbi;
     nnzbi++;
   }
   else { /*(cmpval == 0)*/
     $nzai(NnzC=>nnzci) = nnzai;
     $nzbi(NnzC=>nnzci) = nnzbi;
     nnzai++;
     nnzbi++;
   }
 }
 //
 //-- set output values
 $nzai_nxt() = nnzai;
 $nzbi_nxt() = nnzbi;
 $nzci_nxt() = nnzci;
)),
  Doc =>
(q(
Partially aligns a pair lexicographically sorted index-vector lists C<$ixa()> and C<$ixb()>,
e.g. for block-wise incremental computation of binary operations over sparse index-encoded PDLs.

On return, the vectors C<$nzai> and C<$nzbi> hold indices into C<NnzA> and C<NnzB>
respectively, and are constructed such that:

 ($ixa(,$nzai) <= $ixb(,$nzbi)) whenever ($nzai >= 0 && $nzbi >= 0)

Negative values in the output index vectors C<$nzai> and C<$nzbi> indicate
unalignable key vectors in the alternative index list.

 ($nzai(i) < 0) implies there is no j such that ($ixa(,i) == $ixb(,j))

At most C<NnzC> alignments are performed, and alignment ceases
as soon as any of the PDLs C<$ixa()>, C<$ixb()>, C<$nzai()>, or C<$nzbi()>
has been exhausted.

The output parameters C<$nzai_nxt()>, C<$nzbi_nxt()>, and C<$nzci_nxt()>
return the first unaligned index of the respective PDL.
)),

 ); ##--/ccs_binop_align_block


##======================================================================
## IDEA:
##  ccs_binop_${OP}(int    ixa(NdimsA,NnzA),    nza(NnzA),    missinga(),
##                  int    ixb(NdimsB,NnzB),    nzb(NnzB),    missingb(),
##                  int [o]ixc(NdimsC,NnzC), [o]nzc(NnzC), [o]missingc())
##  + where:
##    - NdimsA==NdimsB==NdimsC  ##-- simple case: no (pseudo-)threading
##    - NnzC <= NnzA+NnzB       ##-- add auto-trimming in PMCode
##    - ixa() and ixb() are both sorted
##
##  + idea: basic algorithm
##    - traverse ixa(),ixb() in parallel (as for vv_union() & friends)
##    - dispatch at each position:
##      ~ CASE ixa(,ai) == ixb(,bi) : INSERT ( ixa(,ai) => ixa(,ai)   ${OP} ixb(,bi)   ); ai++; bi++;
##      ~ CASE ixa(,ai) <  ixb(,bi) : INSERT ( ixa(,ai) => ixa(,ai)   ${OP} missingb() ); ai++;
##      ~ CASE ixa(,ai) >  ixb(,bi) : INSERT ( ixb(,bi) => missinga() ${OP} ixb(,bi)   );       bi++;
##    - DO auto-detect "missingOut" values, e.g. add 'tmp_isgood' check
##
##  + extension: pseudo-threading
##    - idea: allow (NdimsA != NdimsB)
##      ~ generalize to highest order: set NdimsC = max(NdimsA,NdimsB)
##      ~ also allow PMCode to dispatch s.t. (NdimsB <= NdimsA)
##      ~ then, vector comparison is: ixa(0..(NdimsB-1),ai) <=> ixb(,bi)
##        * requires home-grown CMPVEC or extension of PDL::VectorValued $CMPVEC() macro
##        * this allows ixb() to thread over INITIAL dimensions (a la PDL threading)
##        * still doesn't generalize to VECTORS ~ dimension-mismatches where e.g. NdimsB(dimi)==1
##      ~ also wreaks havoc with the case-based increment strategy above:
##        * if (NdimsB < NdimsA), we might well have multiple matches on a single ixb(,bi)
##        * third insertion case may induce a dense matrix, b/c requires implicit iteration:
##             { insert( ixb(,bi) => missinga() ${OP} ixb(,bi) ); bi++ }
##          + this won't cut the sparse butter though, since ixb(,bi) ~= $ixb(,bi).cat_{di=1}^{NdimsA-NdimsB)(seq(di))
##      ~ maybe abstract "alignment" code (ixa(,ai)<=>ixb(,bi)) to its own function
##        and do the rest in perl?
##        * ccs_binop_align( ixa(), ixb(), int [o]ai(NnzC), int [o]bi(NnC) )
##          - here, we can use a constant (say, -1 or BAD) to indicate "no-match", e.g.
##              ai->isbad()   iff.   ixa(,ai) <  ixb(,bi)
##              bi->isbad()   iff.   ixa(,ai) >  ixb(,bi)
##          - maybe 'annihilator assumption' from compat vector-ops can save us ...

##======================================================================
## Footer Administrivia
##======================================================================

##------------------------------------------------------
## pm additions: footer
pp_addpm(<<'EOPM');

##---------------------------------------------------------------------
=pod

=head1 ACKNOWLEDGEMENTS

Perl by Larry Wall.

PDL by Karl Glazebrook, Tuomas J. Lukka, Christian Soeller, and others.

=cut

##----------------------------------------------------------------------
=pod

=head1 KNOWN BUGS

No support for (pseudo)-threading.

=cut


##---------------------------------------------------------------------
=pod

=head1 AUTHOR

Bryan Jurish E<lt>moocow@ling.uni-potsdam.deE<gt>

=head2 Copyright Policy

All other parts Copyright (C) 2007, Bryan Jurish. All rights reserved.

This package is free software, and entirely without warranty.
You may redistribute it and/or modify it under the same terms
as Perl itself.

=head1 SEE ALSO

perl(1), PDL(3perl)

=cut

EOPM


# Always make sure that you finish your PP declarations with
# pp_done
pp_done();
##----------------------------------------------------------------------
