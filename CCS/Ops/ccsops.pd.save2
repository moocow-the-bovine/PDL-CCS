##-*- Mode: CPerl -*-

##======================================================================
## Header Administrivia
##======================================================================

use PDL::VectorValued::Dev;
require "../Version.pm";
our $VERSION = $PDL::CCS::VERSION;
pp_setversion($VERSION);

##------------------------------------------------------
## pm headers
pp_addpm({At=>'Top'},<<'EOPM');

#use PDL::CCS::Version;
use strict;

=pod

=head1 NAME

PDL::CCS::Ops - Low-level binary operations for compressed storage sparse PDLs

=head1 SYNOPSIS

 use PDL;
 use PDL::CCS::Utils;

 ##---------------------------------------------------------------------
 ## ... stuff happens

=cut

EOPM
## /pm additions
##------------------------------------------------------

##------------------------------------------------------
## Exports: None
#pp_export_nothing();

##------------------------------------------------------
## Includes / defines
pp_addhdr(<<'EOH');

#include <math.h>

/*---- BEGIN macros lifted from $PDL_SRC_ROOT/Basic/Ops/ops.pd ---*/
/* MOD requires hackage to map properly into the positive-definite numbers. */
/* Note that this code causes some warning messages in the compile, because */
/* the unsigned data types always fail the ((foo)<0) tests.  I believe that */
/* gcc optimizes those tests away for those data types.  --CED 7-Aug-2002   */

#define MOD(X,N) (  ((N) == 0)   ?    0   :   (   (X) - (ABS(N))  *  ((int)((X)/(ABS(N))) + (   ( ((N) * ((int)((X)/(N)))) != (X) )   ?   ( ( ((N)<0) ? 1 : 0 )  +  ( (((X)<0) ? -1 : 0)))  :  0 ))))

#define SPACE(A,B)   ( ((A)<(B)) ? -1 : ((A)!=(B)) )
#define ABS(A)       ( (A)>=0 ? (A) : -(A) )
#define NOTHING
/*---- END macros lifted from $PDL_SRC_ROOT/Basic/Ops/ops.pd ---*/

EOH


##======================================================================
## C Utilities
##======================================================================
# (none)

##======================================================================
## PDL::PP Wrappers
##======================================================================


##======================================================================
## Operations: Binary: GENERIC
##======================================================================

## %vvpp_def_hash = ccs_binop_hash($op_codename, $op_docname, %args)
## + known %args
##    out_type        => $pptype_or_undef,   ##-- set type of output $nzvals (default: match input $nzvals)
##    out_type_perl   => $perlcode_or_undef, ##-- set output perl type (e.g. out_type_perl=>'PDL::long()')
##    opsub           => \&perl_sub,         ##-- called as $sub->($aval_str,$bval_str,$cval_str), returns pp code
##    cop             => $c_op_str,          ##-- default \&op_sub for C operations
##    init_code       => $ppcode_or_undef,   ##-- misc initialization
##    extra_doc       => $extra_doc,         ##-- additional documentation
##    extra           => \%extraPPArgs,      ##-- extra args for vvpp_def()
sub ccs_binop_hash {
  my ($op_codename,$op_docname,%args) = @_;
  my $cop = $args{cop};
  $args{opsub} = sub { "$_[2] = (($_[0]) ${cop} ($_[1]));" } if (defined($args{cop}));
  die ("ccs_binop_hash(): no opsub defined for op '$op_codename'!") if (!defined($args{opsub}));
  return
    (
     Pars => ("\n    "
	      .join("\n    ",
		    'int    ixa(Ndims,NnzA);    nza(NnzA);    missinga();',
		    'int    ixb(Ndims,NnzB);    nzb(NnzB);    missingb();',
		    (
		     'int [o]ixc(Ndims,NnzC);'
		     .(($args{out_type}||'').' [o]nzc(NnzC);')
		     .(($args{out_type}||'').' [o]missingc();')
		    ),
		    'int [o]nnzai_nxt(); int [o]nnzbi_nxt(); int [o]nnzci_nxt();',
		    '')),

   PMCode =>
('
 sub PDL::ccs_binop_'.${op_codename}.' {
   my ($ixa,$nza,$za, $ixb,$nzb,$zb, $ixc,$nzc,$zc, $nnzai_nxt,$nnzbi_nxt,$nnzci_nxt) = @_;
   ##
   ##-- init: get dimensions
   my ($ndimsA,$nnzA,@tdimsA) = $ixa->dims;
   my ($ndimsB,$nnzB,@tdimsB) = $ixb->dims;
   barf("PDL::ccs_binop_'.$op_codename.'(): no support for NdimsA!=NdimsB ($ndimsA!=$ndimsB)")
      if ($ndimsA != $ndimsB);
   barf("PDL::ccs_binop_'.$op_codename.'(): threaded dimension mismatch")
     if ($#tdimsA != $#tdimsB || grep {$tdimsA[$_] != $tdimsB[$_]} (0..$#tdimsA));
   my ($ndimsC,$nnzC,@tdimsC);
   if (defined($ixc)) {
     ($ndimsC,$nnzC,@tdimsC) = $ixc->dims;
   } else {
     $ndimsC=$ndimsA;
   }
   ($nnzC,@tdimsC) = $nzc->dims if (!defined($nnzC) && defined($nzc) && !$nzc->isempty);
   if (!defined($nnzC)) {
     $nnzC   = $nnzA+$nnzB;
     @tdimsC = @tdimsA;
   } else {
     ##-- sanity check
     barf("PDL::ccs_binop_'.$op_codename.'(): no support for NdimsA!=NdimsC ($ndimsA!=$ndimsC)")
       if ($ndimsA != $ndimsC);
     barf("PDL::ccs_binop_'.$op_codename.'(): threaded dimension mismatch")
       if ($#tdimsA != $#tdimsC || grep {$tdimsA[$_] != $tdimsC[$_]} (0..$#tdimsA));
   }
   ##
   ##-- allocate
   $ixc = PDL->zeroes(PDL::long(), $ndimsC,$nnzC,@tdimsC)
      if (!defined($ixc));
   $nzc = PDL->zeroes('.($args{out_type_perl}||'$nza->type').', $nnzC,@tdimsC)
      if (!defined($nzc));
   $zc  = PDL->zeroes($nzc->type, 1,@tdimsC)       if (!defined($zc));
   $nnzai_nxt = PDL->zeroes(PDL::long(),1,@tdimsC) if (!defined($nnzai_nxt));
   $nnzbi_nxt = PDL->zeroes(PDL::long(),1,@tdimsC) if (!defined($nnzbi_nxt));
   $nnzci_nxt = PDL->zeroes(PDL::long(),1,@tdimsC) if (!defined($nnzci_nxt));
   ##
   ##-- internal call
   &PDL::_ccs_binop_'.$op_codename.'_int($ixa,$nza,$za, $ixb,$nzb,$zb, $ixc,$nzc,$zc, $nnzai_nxt,$nnzbi_nxt,$nnzci_nxt);
   ##
   ##-- auto-trim
   my $trimto = $nnzci_nxt->max-1;
   $ixc = $ixc->slice(",0:$trimto");
   $nzc = $nzc->slice("0:$trimto");
   return wantarray ? ($ixc,$nzc,$zc) : $nzc;
 }
'),
   Code =>
(q(
 long nnzai, nnzbi, nnzci=0;
 long sizeNnzA=$SIZE(NnzA), sizeNnzB=$SIZE(NnzB), sizeNnzC=$SIZE(NnzC);
 int ixaval,ixbval,cmpval;
 $GENERIC(nzc) zvala, zvalb, zvalc, nzvalc;
 ).($args{decls}||'').q(
 //
 //-- init
 zvala = $missinga();
 zvalb = $missingb();
 ).$args{opsub}->('zvala','zvalb','zvalc').q(
 //
 //-- main loop
 for ( nnzai=0,nnzbi=0; nnzai<sizeNnzA && nnzbi<sizeNnzB && nnzci<sizeNnzC; ) {
   $CMPVEC('$ixa(NnzA=>nnzai)','$ixb(NnzB=>nnzbi)','Ndims','cmpval',var1=>'ixaval',var2=>'ixbval');
   if (cmpval < 0) {
     //-- CASE ixa(,ai) <  ixb(,bi) : INSERT ( ixa(,ai) => ixa(,ai)   ${OP} missingb() ); ai++;
     ).$args{opsub}->('$nza(NnzA=>nnzai)', 'zvalb', 'nzvalc').q(
     if (nzvalc != zvalc) {
       loop (Ndims) %{ $ixc(NnzC=>nnzci) = $ixa(NnzA=>nnzai); %}
       $nzc(NnzC=>nnzci) = nzvalc;
       nnzci++;
     }
     nnzai++;
   }
   else if (cmpval > 0) {
     //-- CASE ixa(,ai) >  ixb(,bi) : INSERT ( ixb(,bi) => missinga() ${OP} ixb(,bi)   );       bi++;
     ).$args{opsub}->('zvala', '$nzb(NnzB=>nnzbi)', 'nzvalc').q(
     if (nzvalc != zvalc) {
       loop (Ndims) %{ $ixc(NnzC=>nnzci) = $ixb(NnzB=>nnzbi); %}
       $nzc(NnzC=>nnzci) = nzvalc;
       nnzci++;
     }
     nnzbi++;
   }
   else { /*(cmpval == 0)*/
     //-- CASE ixa(,ai) == ixb(,bi) : INSERT ( ixa(,ai) => ixa(,ai)   ${OP} ixb(,bi)   ); ai++; bi++;
     ).$args{opsub}->('$nza(NnzA=>nnzai)', '$nzb(NnzB=>nnzbi)', 'nzvalc').q(
     if (nzvalc != zvalc) {
       loop (Ndims) %{ $ixc(NnzC=>nnzci) = $ixa(NnzA=>nnzai); %}
       $nzc(NnzC=>nnzci) = nzvalc;
       nnzci++;
     }
     nnzai++;
     nnzbi++;
   }
 }
 //
 //-- gobble remaining values from a()
 for ( ; nnzai<sizeNnzA && nnzci<sizeNnzC; nnzai++) {
   //-- CASE ixa(,ai) <  ixb(,bi) : INSERT ( ixa(,ai) => ixa(,ai)   ${OP} missingb() ); ai++;
   ).$args{opsub}->('$nza(NnzA=>nnzai)', 'zvalb', 'nzvalc').q(
   if (nzvalc != zvalc) {
     loop (Ndims) %{ $ixc(NnzC=>nnzci) = $ixa(NnzA=>nnzai); %}
     $nzc(NnzC=>nnzci) = nzvalc;
     nnzci++;
   }
 }
 //
 //-- gobble remaining values from b()
 for ( ; nnzbi<sizeNnzB && nnzci<sizeNnzC; nnzbi++) {
   //-- CASE ixa(,ai) >  ixb(,bi) : INSERT ( ixb(,bi) => missinga() ${OP} ixb(,bi)   );       bi++;
   ).$args{opsub}->('zvala', '$nzb(NnzB=>nnzbi)', 'nzvalc').q(
   if (nzvalc != zvalc) {
     loop (Ndims) %{ $ixc(NnzC=>nnzci) = $ixb(NnzB=>nnzbi); %}
     $nzc(NnzC=>nnzci) = nzvalc;
     nnzci++;
   }
 }
 //
 //-- set remaining output values
 $nnzai_nxt() = nnzai;
 $nnzbi_nxt() = nnzbi;
 $nnzci_nxt() = nnzci;
 $missingc() = zvalc;
 for ( ; nnzci<sizeNnzC; nnzci++) {
   loop (Ndims) %{ $ixc(NnzC=>nnzci) = -1; %}
   $nzc(NnzC=>nnzci) = zvalc;
 }
)),
  Doc =>
(q(
Binary ).${op_docname}.q( on sparse index-encoded PDLs.

The triples C<($ixa,$nza,$missinga)> and C<($ixb,$nzb,$missingb)> are treated as
index-encoded sparse C<Ndims>-dimensional data PDLs.  Both C<$ixa()> and C<$ixb()>
must be sorted in lexicographic order, i.e. according to the specifications for C<qsortvec()>.

On return, the triple
C<($ixc,$nzc,$missingc)> holds the result of the operation encoded as yet
another sparse index-encoded PDL such that C<NnzC> E<lt>= C<(NnzA+NnzB)>.
Missing values in either or both input triples should be handled correctly.

Returned values are automagically sliced on the C<NnzC> dimension
to the actual number of computed non-C<$missingc()> values in C<$nzc()>, by means of
the pseudo-temporary parameter C<$nnzci_nxt()>.
The index output parameters C<$nnzai_nxt()>, C<$nnzbi_nxt()>, and C<$nnzci_nxt()>
can be used for block-wise computation at the perl level, but are never explicitly returned:
if you need them, you must specify them yourself.  In such cases,
you should probably be calling PDL::_ccs_binop_).$op_codename.q(_int() directly anyways.

In scalar context, returns only C<$nzc()>.

)),
  ##
  ##-- extra user arguments
  ($args{extra} ? %{$args{extra}} : qw()),
 ); ##--/ccs_binop_hash: return
} ##--/ccs_binop_hash: sub

sub ccs_binop_def {
  vvpp_def(('ccs_binop_'.$_[0]), ccs_binop_hash(@_));
}

##--------------------------------------------------------------
## Binary Operations: arithmetic
ccs_binop_def('plus',   'addition',        cop=>'+');
ccs_binop_def('minus',  'subtraction',     cop=>'-');
ccs_binop_def('mult',   'multiplication',  cop=>'*');
ccs_binop_def('divide', 'division',        cop=>'/');
ccs_binop_def('modulo', 'modulo-division',  opsub=>sub{"$_[2]=MOD($_[0],$_[1]);"});
ccs_binop_def('power',  'potentiation (a**b)', opsub=>sub{"$_[2]=pow($_[0],$_[1]);"},   extra=>{GenericTypes=>['D']});
ccs_binop_def('atan2',  'atan2',           opsub=>sub{"$_[2]=atan2($_[0],$_[1]);"}, extra=>{GenericTypes=>['D']});

##--------------------------------------------------------------
## Binary Operations: comparisons
ccs_binop_def('gt', 'greater-than',           cop=>'>');
ccs_binop_def('ge', 'greater-than-or-equal',  cop=>'>=');
ccs_binop_def('lt', 'less-than',              cop=>'<');
ccs_binop_def('le', 'less-than-or-equal',     cop=>'<=');
ccs_binop_def('eq', 'equality',               cop=>'==');
ccs_binop_def('ne', 'inequality',             cop=>'!=');
ccs_binop_def('spaceship', '3-way comparison', opsub=>sub{"$_[2]=SPACE(($_[0]),($_[1]));"});

##--------------------------------------------------------------
## Binary Operations: logical & bitwise
my %int_only = ( extra=>{GenericTypes=>['B','U','S','L']} ); ##-- integer types
ccs_binop_def('and2',       'bitwise I<and> (a&b)',          cop=>'&',  %int_only);
ccs_binop_def('or2',        'bitwise I<or> (a|b)',           cop=>'|',  %int_only);
ccs_binop_def('xor',        'bitwise I<exclusive or> (a^b)', cop=>'^',  %int_only);
ccs_binop_def('shiftleft',  'bitwise left-shift (a<<b)',     cop=>'<<', %int_only);
ccs_binop_def('shiftright', 'bitwise right-shift (a>>b)',    cop=>'>>', %int_only);


##======================================================================
## IDEA:
##  ccs_binop_${OP}(int    ixa(NdimsA,NnzA),    nza(NnzA),    missinga(),
##                  int    ixb(NdimsB,NnzB),    nzb(NnzB),    missingb(),
##                  int [o]ixc(NdimsC,NnzC), [o]nzc(NnzC), [o]missingc())
##  + where:
##    - NdimsA==NdimsB==NdimsC  ##-- simple case: no (pseudo-)threading
##    - NnzC <= NnzA+NnzB       ##-- add auto-trimming in PMCode
##    - ixa() and ixb() are both sorted
##
##  + idea: basic algorithm
##    - traverse ixa(),ixb() in parallel (as for vv_union() & friends)
##    - dispatch at each position:
##      ~ CASE ixa(,ai) == ixb(,bi) : INSERT ( ixa(,ai) => ixa(,ai)   ${OP} ixb(,bi)   ); ai++; bi++;
##      ~ CASE ixa(,ai) <  ixb(,bi) : INSERT ( ixa(,ai) => ixa(,ai)   ${OP} missingb() ); ai++;
##      ~ CASE ixa(,ai) >  ixb(,bi) : INSERT ( ixb(,bi) => missinga() ${OP} ixb(,bi)   );       bi++;
##    - DO auto-detect "missingOut" values, e.g. add 'tmp_isgood' check
##
##  + extension: pseudo-threading
##    - idea: allow (NdimsA != NdimsB)
##      ~ generalize to highest order: set NdimsC = max(NdimsA,NdimsB)
##      ~ also allow PMCode to dispatch s.t. (NdimsB <= NdimsA)
##      ~ then, vector comparison is: ixa(0..(NdimsB-1),ai) <=> ixb(,bi)
##        * requires home-grown CMPVEC or extension of PDL::VectorValued $CMPVEC() macro
##        * this allows ixb() to thread over INITIAL dimensions (a la PDL threading)
##        * still doesn't generalize to VECTORS ~ dimension-mismatches where e.g. NdimsB(dimi)==1
##      ~ also wreaks havoc with the case-based increment strategy above:
##        * if (NdimsB < NdimsA), we might well have multiple matches on a single ixb(,bi)
##        * third insertion case may induce a dense matrix, b/c requires implicit iteration:
##             { insert( ixb(,bi) => missinga() ${OP} ixb(,bi) ); bi++ }
##          + this won't cut the sparse butter though, since ixb(,bi) ~= $ixb(,bi).cat_{di=1}^{NdimsA-NdimsB)(seq(di))
##      ~ maybe abstract "alignment" code (ixa(,ai)<=>ixb(,bi)) to its own function
##        and do the rest in perl?
##        * ccs_binop_align( ixa(), ixb(), int [o]ai(NnzC), int [o]bi(NnC) )
##          - here, we can use a constant (say, -1 or BAD) to indicate "no-match", e.g.
##              ai->isbad()   iff.   ixa(,ai) <  ixb(,bi)
##              bi->isbad()   iff.   ixa(,ai) >  ixb(,bi)
##          - maybe 'annihilator assumption' from compat vector-ops can save us ...

##======================================================================
## Footer Administrivia
##======================================================================

##------------------------------------------------------
## pm additions: footer
pp_addpm(<<'EOPM');

##---------------------------------------------------------------------
=pod

=head1 ACKNOWLEDGEMENTS

Perl by Larry Wall.

PDL by Karl Glazebrook, Tuomas J. Lukka, Christian Soeller, and others.

Some useful C macros copied verbatim from $PDL_SRC_ROOT/Basic/Ops/ops.pd.

=cut

##----------------------------------------------------------------------
=pod

=head1 KNOWN BUGS

No support for (pseudo)-threading.

=cut


##---------------------------------------------------------------------
=pod

=head1 AUTHOR

Bryan Jurish E<lt>moocow@ling.uni-potsdam.deE<gt>

=head2 Copyright Policy

C macros from $PDL_SRC_ROOT/Basic/Ops/ops.pd copyright
their respective authors.  See the file COPYING in the
PDL distribution for details.

All other parts Copyright (C) 2007, Bryan Jurish. All rights reserved.

This package is free software, and entirely without warranty.
You may redistribute it and/or modify it under the same terms
as Perl itself.

=head1 SEE ALSO

perl(1), PDL(3perl)

=cut

EOPM


# Always make sure that you finish your PP declarations with
# pp_done
pp_done();
##----------------------------------------------------------------------
