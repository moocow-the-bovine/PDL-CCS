## -*- Mode: CPerl -*-

##!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
## ccsops.pd: (almost-)safe (but expensive) alignment stuff
##!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

##======================================================================
## Operations: Binary: ALIGN: safe: test
##======================================================================

pp_def
  ('ccs_index_block',
   Pars => ('int dims(Ndims); int ixfirst(Ndims); int [o]ixblock(Ndims,Nix); int [o]nix_got();'),
   Code =>
(q(
 long sizeNdims=$SIZE(Ndims), sizeNix=$SIZE(Nix), ndimsMax=sizeNdims-1;
 long dimi, nixi=1, nixi_prev=0;
 long dimval;
 //
 //-- init: copy ixfirst() to ixblock()
 loop (Ndims) %{ $ixblock(Nix=>0) = $ixfirst(); %}
 //
 //-- main loop: increment & generate indices
 for ( ; nixi<sizeNix; nixi_prev=nixi++) {
   for (dimi=ndimsMax; dimi >= 0; dimi--) {
     dimval = $ixblock(Ndims=>dimi,Nix=>nixi_prev) + 1;
     if (dimval < $dims(Ndims=>dimi)) {
       $ixblock(Ndims=>dimi,Nix=>nixi) = dimval;
       break;
     }
     $ixblock(Ndims=>dimi,Nix=>nixi) = dimval = 0;
   }
   if (dimi<0 && dimval==0) break;
   for (dimi--; dimi>=0; dimi--) {
     $ixblock(Ndims=>dimi,Nix=>nixi) = $ixblock(Ndims=>dimi,Nix=>nixi_prev);
   }
 }
 $nix_got() = nixi;
)),
  Doc =>
(q{test routine: not yet documented}),
 ); ##--/ccs_index_block

##======================================================================
## Operations: Binary: ALIGN: safe: utils
##======================================================================
*vvpp_pdlvar_basename = \&PDL::VectorValued::Dev::vvpp_pdlvar_basename;

##--------------------------------------------------------------
## Align: safe: increment index vector : $IXINCR(ixvec,dimvec)
##
##  + requires PDLs
##     ${dimvec}(Ndims)  : dimension vector for ${ixvec}: no virtuals!
##     ${ixvec}          : index-vector iterator to increment
##  + uses C variables
##     int+ dimi
##     int+ dimval
##  + requires C variables
##     ndimsMax = $SIZE(Ndims)-1
##  + on completion, end-of-iteration is indicated by:
##     (dimi<0)

sub ixincr_code {
  my ($ixvec,$dimvec) = @_;
  ##
  ##-- sanity checks
  my $USAGE = 'ixincr_code(ixvec,dimvec);'
  die ("Usage: $USAGE") if (@_ < 2 || grep {!defined($_)} @_[0..2]);
  ##
  ##-- get PDL variable basenames
  my $ixvecname = vvpp_pdlvar_basename($vec1);
  my $ixveci    = $ixvecname;
  $ixveci       =~ s/^\s*\(//;
  $ixveci       =~ s/\)*$//;
  my $ppcode = '';
  ##
  ##-- generate comparison code
  $ppcode .= <<"EOPP";
  /*-- BEGIN ixincr_code --*/
  for (dimi=ndimsMax; dimi>=0; dimi--) {
    dimval = 1+${ixvecname}(${ixveci},Ndims=>dimi);
    if (dimval < ${dimvec}(Ndims=>dimi)) {
      ${ixvec}(Ndims=>dimi) = dimval;
      break;
    }
    ${ixvec}(${ixveci},Ndims=>dimi) = dimval;
  }
  /*-- END ixincr_code: done if dimi<0 --*/
EOPP
  ##
  ##-- ... and return
  return $ppcode;
}
sub expand_ixincr {
  my $str = shift;
  $str =~ s{\$IXINCR\s*\((.*)\)}{ixincr_code(eval($1))}emg; ##-- single-line macros ONLY
  return $str;
}
push(@PDL::VectorValued::Dev::MACROS, \&expand_ixincr);

##--------------------------------------------------------------
## Align: safe: compare ixval <=> iterval : $IXCMP(ixvec,dimvec)
##
##  + requires PDLs
##     int ixiter(Ndims) : index-vector iterator
##     ${dimvec}(Ndims)  : dimension vector for ${ixvec}: dims<0 are "virtual"
##     ${ixvec}          : index vector to compare to $ixiter() along "Ndims"; may be partially indexed
##  + uses C variables
##     int+ dimi
##     int+ dimval
##     int+ ixval
##     int+ iterval
##     int+ cmpval
##  + requires C variables
##     ndimsMax = $SIZE(Ndims)-1

sub ixcmp_code {
  my ($ixvec,$dimvec) = @_;
  ##
  ##-- sanity checks
  my $USAGE = 'ixcmp_code(ixvec,dimvec);'
  die ("Usage: $USAGE") if (@_ < 2 || grep {!defined($_)} @_[0..2]);
  ##
  ##-- get PDL variable basenames
  my $ixvecname = vvpp_pdlvar_basename($vec1);
  my $ixveci    = $ixvecname;
  $ixveci       =~ s/^\s*\(//;
  $ixveci       =~ s/\)*$//;
  my $ppcode = '';
  ##
  ##-- generate comparison code
  $ppcode .= <<"EOPP";
  /*-- BEGIN ixcmp_code --*/
  cmpval=0;
  for (dimi=ndimsMax; dimi>=0; dimi--) {
    dimval=${dimvec}(Ndims=>dimi);
    if (dimval<=1) { continue; } //-- virtual dimension or size=1 always matches
    ixval   = ${ixvec}(${ixveci},Ndims=>dimi);
    iterval = \$ixiter(Ndims=>dimi);
    if      (ixval < iterval) { cmpval=-1; break; }
    else if (ixval > iterval) { cmpval= 1; break; }
  }
  /*-- END ixmp_code --*/
EOPP
  ##
  ##-- ... and return
  return $ppcode;
}
sub expand_ixcmp {
  my $str = shift;
  $str =~ s{\$IXCMP\s*\((.*)\)}{ixcmp_code(eval($1))}emg; ##-- single-line macros ONLY
  return $str;
}
push(@PDL::VectorValued::Dev::MACROS, \&expand_ixcmp);


##--------------------------------------------------------------
## Align: safe: guts
vvpp_def
  ('ccs_binop_align_block_safe',
   Pars => ("\n    "
	    .join("\n    ",
		  'int adims(Ndims);    int ixa(Ndims,NnzA);',
		  'int bdims(Ndims);    int ixb(Ndims,NnzB);',
		  'int istate(State);',
		  'int cdims(Ndims);    int [o]ixc(Ndims,NnzC);',
		  'int [o]nzai(NnzC);   int [o]nzbi(NnzC);'
		  'int [o]ostate(State);',
		  'int [t]ixiter(Ndims);',
		  '')),
   Code =>
(q(
 long sizeNnzA=$SIZE(NnzA), sizeNnzB=$SIZE(NnzB), sizeNnzC=$SIZE(NnzC), sizeNdims=$SIZE(Ndims), ndimsMax=sizeNdims-1;
 long dimi,dimval,ixval,iterval;
 int cmpval;
 //
 pdl_barf("ccs_binop_align_block_safe(): not yet implemented");
)),
  Doc=>
(q{Not yet documented
}),
  ); ##--/ccs_binop_align_block_safe


##======================================================================
## IDEA:
##  ccs_binop_${OP}(int    ixa(NdimsA,NnzA),    nza(NnzA),    missinga(),
##                  int    ixb(NdimsB,NnzB),    nzb(NnzB),    missingb(),
##                  int [o]ixc(NdimsC,NnzC), [o]nzc(NnzC), [o]missingc())
##  + where:
##    - NdimsA==NdimsB==NdimsC  ##-- simple case: no (pseudo-)threading
##    - NnzC <= NnzA+NnzB       ##-- add auto-trimming in PMCode
##    - ixa() and ixb() are both sorted
##
##  + idea: basic algorithm
##    - traverse ixa(),ixb() in parallel (as for vv_union() & friends)
##    - dispatch at each position:
##      ~ CASE ixa(,ai) == ixb(,bi) : INSERT ( ixa(,ai) => ixa(,ai)   ${OP} ixb(,bi)   ); ai++; bi++;
##      ~ CASE ixa(,ai) <  ixb(,bi) : INSERT ( ixa(,ai) => ixa(,ai)   ${OP} missingb() ); ai++;
##      ~ CASE ixa(,ai) >  ixb(,bi) : INSERT ( ixb(,bi) => missinga() ${OP} ixb(,bi)   );       bi++;
##    - DO auto-detect "missingOut" values, e.g. add 'tmp_isgood' check
##
##  + extension: pseudo-threading
##    - idea: allow (NdimsA != NdimsB)
##      ~ generalize to highest order: set NdimsC = max(NdimsA,NdimsB)
##      ~ also allow PMCode to dispatch s.t. (NdimsB <= NdimsA)
##      ~ then, vector comparison is: ixa(0..(NdimsB-1),ai) <=> ixb(,bi)
##        * requires home-grown CMPVEC or extension of PDL::VectorValued $CMPVEC() macro
##        * this allows ixb() to thread over INITIAL dimensions (a la PDL threading)
##        * still doesn't generalize to VECTORS ~ dimension-mismatches where e.g. NdimsB(dimi)==1
##      ~ also wreaks havoc with the case-based increment strategy above:
##        * if (NdimsB < NdimsA), we might well have multiple matches on a single ixb(,bi)
##        * third insertion case may induce a dense matrix, b/c requires implicit iteration:
##             { insert( ixb(,bi) => missinga() ${OP} ixb(,bi) ); bi++ }
##          + this won't cut the sparse butter though, since ixb(,bi) ~= $ixb(,bi).cat_{di=1}^{NdimsA-NdimsB)(seq(di))
##      ~ maybe abstract "alignment" code (ixa(,ai)<=>ixb(,bi)) to its own function
##        and do the rest in perl?
##        * ccs_binop_align( ixa(), ixb(), int [o]ai(NnzC), int [o]bi(NnC) )
##          - here, we can use a constant (say, -1 or BAD) to indicate "no-match", e.g.
##              ai->isbad()   iff.   ixa(,ai) <  ixb(,bi)
##              bi->isbad()   iff.   ixa(,ai) >  ixb(,bi)
##          - maybe 'annihilator assumption' from compat vector-ops can save us ...


##!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
## ccsops.pd: saved v4
##!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

##======================================================================
## Header Administrivia
##======================================================================

use PDL::VectorValued::Dev;
require "../Version.pm";
our $VERSION = $PDL::CCS::VERSION;
pp_setversion($VERSION);

##------------------------------------------------------
## pm headers
pp_addpm({At=>'Top'},<<'EOPM');

#use PDL::CCS::Version;
use strict;

=pod

=head1 NAME

PDL::CCS::Ops - Low-level binary operations for compressed storage sparse PDLs

=head1 SYNOPSIS

 use PDL;
 use PDL::CCS::Utils;

 ##---------------------------------------------------------------------
 ## ... stuff happens

=cut

EOPM
## /pm additions
##------------------------------------------------------

##------------------------------------------------------
## Exports: None
#pp_export_nothing();

##------------------------------------------------------
## Includes / defines
pp_addhdr(<<'EOH');
EOH


##======================================================================
## C Utilities
##======================================================================
# (none)

##======================================================================
## PDL::PP Wrappers
##======================================================================


##======================================================================
## Operations: Binary: GENERIC
##======================================================================

vvpp_def
  ('ccs_binop_align_block',
   Pars => ("\n    "
	    .join("\n    ",
		  'int ixa(Ndims,NnzA); int ixb(Ndims,NnzB); int    istate(State);',
		  'int [o]nzai(NnzC);   int [o]nzbi(NnzC);   int [o]ostate(State);',
		  '')),
   Code =>
(q(
 long sizeNnzA=$SIZE(NnzA), sizeNnzB=$SIZE(NnzB), sizeNnzC=$SIZE(NnzC);
 long nnzai=0, nnzbi=0,nnzbi0, nnzci=0, nnzai_nxt=0,nnzbi_nxt=0,nnzci_nxt=0;
 int cmpme1,cmpme2, cmpval=0;
 //
 //-- initialize: parse istate() [ nnzai,nnzai_nxt, nnzbi,nnzbi_nxt, nnzci,nnzci_nxt, cmpval ]
 if ($SIZE(State) >= 7) {
   nnzai     = $istate(State=>0);
   nnzai_nxt = $istate(State=>1);
   nnzbi     = $istate(State=>2);
   nnzbi_nxt = $istate(State=>3);
   nnzci     = $istate(State=>4);
   nnzci_nxt = $istate(State=>5);
   cmpval    = $istate(State=>6);
 }
 //
 //-- main loop: start at current nnzai,nnzbi,nnzci
 for ( ; nnzai<sizeNnzA && nnzbi<sizeNnzB && nnzci_nxt<sizeNnzC; ) {
   //
   //-- dispatch on cached cmpval for current index-runs (nnzai..nnzai_nxt),(nnzbi..nnzbi_nxt)
   if (cmpval < 0) {
     //-- CASE ixa(,ai) < ixb(,bi) : INSERT ( ixa(,ai) => (ixa(,ai) . -1) ); INCR(ai);
     for ( ; nnzai<nnzai_nxt; nnzai++, nnzci++) {
       $nzai(NnzC=>nnzci) = nnzai;
       $nzbi(NnzC=>nnzci) = -1;
     }
     //-- increment ai: detect next run-length
     for (nnzai_nxt=nnzai+1; nnzai_nxt<sizeNnzA; nnzai_nxt++) {
       $CMPVEC('$ixa(NnzA=>nnzai)','$ixa(NnzA=>nnzai_nxt)','Ndims','cmpval',var1=>'cmpme1',var2=>'cmpme2');
       if (cmpval != 0) break;
     }
   }
   else if (cmpval > 0) {
     //-- CASE ixa(,ai) > ixb(,bi) : INSERT ( ixb(,bi) => (-1 . ixb(,bi)) ); INCR(bi);
     for ( ; nnzbi<nnzbi_nxt; nnzbi++, nnzci++) {
       $nzai(NnzC=>nnzci) = -1;
       $nzbi(NnzC=>nnzci) = nnzbi;
     }
     //-- increment bi: detect next run-length
     for (nnzbi_nxt=nnzbi+1; nnzbi_nxt<sizeNnzB; nnzbi_nxt++) {
       $CMPVEC('$ixb(NnzB=>nnzbi)','$ixb(NnzB=>nnzbi_nxt)','Ndims','cmpval',var1=>'cmpme1',var2=>'cmpme2');
       if (cmpval != 0) break;
     }
   }
   else {
     //-- CASE ixa(,ai) == ixb(,bi) : INSERT ( ixa(,ai) => (ixa(,ai) . ixb(,bi)) ); INCR(ai); INCR(bi);
     for (nnzbi0=nnzbi; nnzai<nnzai_nxt; nnzai++) {
       for (nnzbi=nnzbi0; nnzbi<nnzbi_nxt; nnzbi++, nnzci++) {
	 $nzai(NnzC=>nnzci) = nnzai;
	 $nzbi(NnzC=>nnzci) = nnzbi;
       }
     }
     //-- increment ai,bi: detect next run-lengths
     for (nnzai_nxt=nnzai+1; nnzai_nxt<sizeNnzA; nnzai_nxt++) {
       $CMPVEC('$ixa(NnzA=>nnzai)','$ixa(NnzA=>nnzai_nxt)','Ndims','cmpval',var1=>'cmpme1',var2=>'cmpme2');
       if (cmpval != 0) break;
     }
     for (nnzbi_nxt=nnzbi+1; nnzbi_nxt<sizeNnzB; nnzbi_nxt++) {
       $CMPVEC('$ixb(NnzB=>nnzbi)','$ixb(NnzB=>nnzbi_nxt)','Ndims','cmpval',var1=>'cmpme1',var2=>'cmpme2');
       if (cmpval != 0) break;
     }
   }
   //
   //-- compare current index-run values
   $CMPVEC('$ixa(NnzA=>nnzai)','$ixb(NnzB=>nnzbi)','Ndims','cmpval',var1=>'cmpme1',var2=>'cmpme2');
   if      (cmpval < 0) { nnzci_nxt = nnzci + (nnzai_nxt-nnzai); }
   else if (cmpval > 0) { nnzci_nxt = nnzci + (nnzbi_nxt-nnzbi); }
   else                 { nnzci_nxt = nnzci + (nnzai_nxt-nnzai)*(nnzbi_nxt-nnzbi); }
 } //-- end main loop
 //
 //-- gobble leftovers
 if (nnzci<sizeNnzC) {
   if (nnzbi >= sizeNnzB) {
     for ( ; nnzai<sizeNnzA && nnzci<sizeNnzC; nnzai++,nnzci++) {
       $nzai(NnzC=>nnzci) = nnzai;
       $nzbi(NnzC=>nnzci) = -1;
     }
     nnzci_nxt = nnzci;
     cmpval    = -1;
   }
   if (nnzai >= sizeNnzA) {
     for ( ; nnzbi<sizeNnzB && nnzci<sizeNnzC; nnzbi++,nnzci++) {
       $nzai(NnzC=>nnzci) = -1;
       $nzbi(NnzC=>nnzci) = nnzbi;
     }
     nnzci_nxt = nnzci;
     cmpval    = 1;
   }
 }
 //
 //-- save state
 if ($SIZE(State) >= 7) {
   $ostate(State=>0) = nnzai;
   $ostate(State=>1) = nnzai_nxt;
   $ostate(State=>2) = nnzbi;
   $ostate(State=>3) = nnzbi_nxt;
   $ostate(State=>4) = nnzci;
   $ostate(State=>5) = nnzci_nxt;
   $ostate(State=>6) = cmpval;
 }
)),
  Doc =>
(q(
TODO: update docs

Partially aligns a pair lexicographically sorted index-vector lists C<$ixa()> and C<$ixb()>,
e.g. for block-wise incremental computation of binary operations over sparse index-encoded PDLs.

On return, the vectors C<$nzai> and C<$nzbi> hold indices into C<NnzA> and C<NnzB>
respectively, and are constructed such that:

 ($ixa(,$nzai) <= $ixb(,$nzbi)) whenever ($nzai >= 0 && $nzbi >= 0)

Negative values in the output index vectors C<$nzai> and C<$nzbi> indicate
unalignable key vectors in the alternative index list.

 ($nzai(i) < 0) implies there is no j such that ($ixa(,i) == $ixb(,j))

At most C<NnzC> alignments are performed, and alignment ceases
as soon as any of the PDLs C<$ixa()>, C<$ixb()>, C<$nzai()>, or C<$nzbi()>
has been exhausted.

The output parameters C<$nzai_nxt()>, C<$nzbi_nxt()>, and C<$nzci_nxt()>
return the first unaligned index of the respective PDL.
)),

 ); ##--/ccs_binop_align_block


##======================================================================
## IDEA:
##  ccs_binop_${OP}(int    ixa(NdimsA,NnzA),    nza(NnzA),    missinga(),
##                  int    ixb(NdimsB,NnzB),    nzb(NnzB),    missingb(),
##                  int [o]ixc(NdimsC,NnzC), [o]nzc(NnzC), [o]missingc())
##  + where:
##    - NdimsA==NdimsB==NdimsC  ##-- simple case: no (pseudo-)threading
##    - NnzC <= NnzA+NnzB       ##-- add auto-trimming in PMCode
##    - ixa() and ixb() are both sorted
##
##  + idea: basic algorithm
##    - traverse ixa(),ixb() in parallel (as for vv_union() & friends)
##    - dispatch at each position:
##      ~ CASE ixa(,ai) == ixb(,bi) : INSERT ( ixa(,ai) => ixa(,ai)   ${OP} ixb(,bi)   ); ai++; bi++;
##      ~ CASE ixa(,ai) <  ixb(,bi) : INSERT ( ixa(,ai) => ixa(,ai)   ${OP} missingb() ); ai++;
##      ~ CASE ixa(,ai) >  ixb(,bi) : INSERT ( ixb(,bi) => missinga() ${OP} ixb(,bi)   );       bi++;
##    - DO auto-detect "missingOut" values, e.g. add 'tmp_isgood' check
##
##  + extension: pseudo-threading
##    - idea: allow (NdimsA != NdimsB)
##      ~ generalize to highest order: set NdimsC = max(NdimsA,NdimsB)
##      ~ also allow PMCode to dispatch s.t. (NdimsB <= NdimsA)
##      ~ then, vector comparison is: ixa(0..(NdimsB-1),ai) <=> ixb(,bi)
##        * requires home-grown CMPVEC or extension of PDL::VectorValued $CMPVEC() macro
##        * this allows ixb() to thread over INITIAL dimensions (a la PDL threading)
##        * still doesn't generalize to VECTORS ~ dimension-mismatches where e.g. NdimsB(dimi)==1
##      ~ also wreaks havoc with the case-based increment strategy above:
##        * if (NdimsB < NdimsA), we might well have multiple matches on a single ixb(,bi)
##        * third insertion case may induce a dense matrix, b/c requires implicit iteration:
##             { insert( ixb(,bi) => missinga() ${OP} ixb(,bi) ); bi++ }
##          + this won't cut the sparse butter though, since ixb(,bi) ~= $ixb(,bi).cat_{di=1}^{NdimsA-NdimsB)(seq(di))
##      ~ maybe abstract "alignment" code (ixa(,ai)<=>ixb(,bi)) to its own function
##        and do the rest in perl?
##        * ccs_binop_align( ixa(), ixb(), int [o]ai(NnzC), int [o]bi(NnC) )
##          - here, we can use a constant (say, -1 or BAD) to indicate "no-match", e.g.
##              ai->isbad()   iff.   ixa(,ai) <  ixb(,bi)
##              bi->isbad()   iff.   ixa(,ai) >  ixb(,bi)
##          - maybe 'annihilator assumption' from compat vector-ops can save us ...

##======================================================================
## Footer Administrivia
##======================================================================

##------------------------------------------------------
## pm additions: footer
pp_addpm(<<'EOPM');

##---------------------------------------------------------------------
=pod

=head1 ACKNOWLEDGEMENTS

Perl by Larry Wall.

PDL by Karl Glazebrook, Tuomas J. Lukka, Christian Soeller, and others.

=cut

##----------------------------------------------------------------------
=pod

=head1 KNOWN BUGS

No support for (pseudo)-threading.

=cut


##---------------------------------------------------------------------
=pod

=head1 AUTHOR

Bryan Jurish E<lt>moocow@ling.uni-potsdam.deE<gt>

=head2 Copyright Policy

All other parts Copyright (C) 2007, Bryan Jurish. All rights reserved.

This package is free software, and entirely without warranty.
You may redistribute it and/or modify it under the same terms
as Perl itself.

=head1 SEE ALSO

perl(1), PDL(3perl)

=cut

EOPM


# Always make sure that you finish your PP declarations with
# pp_done
pp_done();
##----------------------------------------------------------------------


##!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
## ccsops.pd: saved v3
##!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

##======================================================================
## Header Administrivia
##======================================================================

use PDL::VectorValued::Dev;
require "../Version.pm";
our $VERSION = $PDL::CCS::VERSION;
pp_setversion($VERSION);

##------------------------------------------------------
## pm headers
pp_addpm({At=>'Top'},<<'EOPM');

#use PDL::CCS::Version;
use strict;

=pod

=head1 NAME

PDL::CCS::Ops - Low-level binary operations for compressed storage sparse PDLs

=head1 SYNOPSIS

 use PDL;
 use PDL::CCS::Utils;

 ##---------------------------------------------------------------------
 ## ... stuff happens

=cut

EOPM
## /pm additions
##------------------------------------------------------

##------------------------------------------------------
## Exports: None
#pp_export_nothing();

##------------------------------------------------------
## Includes / defines
pp_addhdr(<<'EOH');
EOH


##======================================================================
## C Utilities
##======================================================================
# (none)

##======================================================================
## PDL::PP Wrappers
##======================================================================


##======================================================================
## Operations: Binary: GENERIC
##======================================================================

vvpp_def
  ('ccs_binop_align_block',
   Pars => ("\n    "
	    .join("\n    ",
		  'int ixa(Ndims,NnzA); int ixb(Ndims,NnzB);',
		  'int [o]nzai(NnzC);   int [o]nzbi(NnzC);',
		  'int [o]nzai_nxt();   int [o]nzbi_nxt();   int [o]nzci_nxt();',
		  '')),
   Code =>
(q(
 long nnzai, nnzbi, nnzci=0;
 long sizeNnzA=$SIZE(NnzA), sizeNnzB=$SIZE(NnzB), sizeNnzC=$SIZE(NnzC);
 int ixaval,ixbval,cmpval;
 //
 //-- main loop
 for ( nnzai=0,nnzbi=0; nnzai<sizeNnzA && nnzbi<sizeNnzB && nnzci<sizeNnzC; nnzci++ ) {
   $CMPVEC('$ixa(NnzA=>nnzai)','$ixb(NnzB=>nnzbi)','Ndims','cmpval',var1=>'ixaval',var2=>'ixbval');
   if (cmpval < 0) {
     //-- CASE ixa(,ai) <  ixb(,bi) : INSERT ( ixa(,ai) => (ixa(,ai) . -1) ); ai++;
     $nzai(NnzC=>nnzci) = nnzai;
     $nzbi(NnzC=>nnzci) = -1;
     nnzai++;
   }
   else if (cmpval > 0) {
     //-- CASE ixa(,ai) >  ixb(,bi) : INSERT ( ixb(,bi) => (-1 . ixb(,bi))  ); bi++;
     $nzai(NnzC=>nnzci) = -1;
     $nzbi(NnzC=>nnzci) = nnzbi;
     nnzbi++;
   }
   else { /*(cmpval == 0)*/
     $nzai(NnzC=>nnzci) = nnzai;
     $nzbi(NnzC=>nnzci) = nnzbi;
     nnzai++;
     nnzbi++;
   }
 }
 //
 //-- set output values
 $nzai_nxt() = nnzai;
 $nzbi_nxt() = nnzbi;
 $nzci_nxt() = nnzci;
)),
  Doc =>
(q(
Partially aligns a pair lexicographically sorted index-vector lists C<$ixa()> and C<$ixb()>,
e.g. for block-wise incremental computation of binary operations over sparse index-encoded PDLs.

On return, the vectors C<$nzai> and C<$nzbi> hold indices into C<NnzA> and C<NnzB>
respectively, and are constructed such that:

 ($ixa(,$nzai) <= $ixb(,$nzbi)) whenever ($nzai >= 0 && $nzbi >= 0)

Negative values in the output index vectors C<$nzai> and C<$nzbi> indicate
unalignable key vectors in the alternative index list.

 ($nzai(i) < 0) implies there is no j such that ($ixa(,i) == $ixb(,j))

At most C<NnzC> alignments are performed, and alignment ceases
as soon as any of the PDLs C<$ixa()>, C<$ixb()>, C<$nzai()>, or C<$nzbi()>
has been exhausted.

The output parameters C<$nzai_nxt()>, C<$nzbi_nxt()>, and C<$nzci_nxt()>
return the first unaligned index of the respective PDL.
)),

 ); ##--/ccs_binop_align_block


##======================================================================
## IDEA:
##  ccs_binop_${OP}(int    ixa(NdimsA,NnzA),    nza(NnzA),    missinga(),
##                  int    ixb(NdimsB,NnzB),    nzb(NnzB),    missingb(),
##                  int [o]ixc(NdimsC,NnzC), [o]nzc(NnzC), [o]missingc())
##  + where:
##    - NdimsA==NdimsB==NdimsC  ##-- simple case: no (pseudo-)threading
##    - NnzC <= NnzA+NnzB       ##-- add auto-trimming in PMCode
##    - ixa() and ixb() are both sorted
##
##  + idea: basic algorithm
##    - traverse ixa(),ixb() in parallel (as for vv_union() & friends)
##    - dispatch at each position:
##      ~ CASE ixa(,ai) == ixb(,bi) : INSERT ( ixa(,ai) => ixa(,ai)   ${OP} ixb(,bi)   ); ai++; bi++;
##      ~ CASE ixa(,ai) <  ixb(,bi) : INSERT ( ixa(,ai) => ixa(,ai)   ${OP} missingb() ); ai++;
##      ~ CASE ixa(,ai) >  ixb(,bi) : INSERT ( ixb(,bi) => missinga() ${OP} ixb(,bi)   );       bi++;
##    - DO auto-detect "missingOut" values, e.g. add 'tmp_isgood' check
##
##  + extension: pseudo-threading
##    - idea: allow (NdimsA != NdimsB)
##      ~ generalize to highest order: set NdimsC = max(NdimsA,NdimsB)
##      ~ also allow PMCode to dispatch s.t. (NdimsB <= NdimsA)
##      ~ then, vector comparison is: ixa(0..(NdimsB-1),ai) <=> ixb(,bi)
##        * requires home-grown CMPVEC or extension of PDL::VectorValued $CMPVEC() macro
##        * this allows ixb() to thread over INITIAL dimensions (a la PDL threading)
##        * still doesn't generalize to VECTORS ~ dimension-mismatches where e.g. NdimsB(dimi)==1
##      ~ also wreaks havoc with the case-based increment strategy above:
##        * if (NdimsB < NdimsA), we might well have multiple matches on a single ixb(,bi)
##        * third insertion case may induce a dense matrix, b/c requires implicit iteration:
##             { insert( ixb(,bi) => missinga() ${OP} ixb(,bi) ); bi++ }
##          + this won't cut the sparse butter though, since ixb(,bi) ~= $ixb(,bi).cat_{di=1}^{NdimsA-NdimsB)(seq(di))
##      ~ maybe abstract "alignment" code (ixa(,ai)<=>ixb(,bi)) to its own function
##        and do the rest in perl?
##        * ccs_binop_align( ixa(), ixb(), int [o]ai(NnzC), int [o]bi(NnC) )
##          - here, we can use a constant (say, -1 or BAD) to indicate "no-match", e.g.
##              ai->isbad()   iff.   ixa(,ai) <  ixb(,bi)
##              bi->isbad()   iff.   ixa(,ai) >  ixb(,bi)
##          - maybe 'annihilator assumption' from compat vector-ops can save us ...

##======================================================================
## Footer Administrivia
##======================================================================

##------------------------------------------------------
## pm additions: footer
pp_addpm(<<'EOPM');

##---------------------------------------------------------------------
=pod

=head1 ACKNOWLEDGEMENTS

Perl by Larry Wall.

PDL by Karl Glazebrook, Tuomas J. Lukka, Christian Soeller, and others.

=cut

##----------------------------------------------------------------------
=pod

=head1 KNOWN BUGS

No support for (pseudo)-threading.

=cut


##---------------------------------------------------------------------
=pod

=head1 AUTHOR

Bryan Jurish E<lt>moocow@ling.uni-potsdam.deE<gt>

=head2 Copyright Policy

All other parts Copyright (C) 2007, Bryan Jurish. All rights reserved.

This package is free software, and entirely without warranty.
You may redistribute it and/or modify it under the same terms
as Perl itself.

=head1 SEE ALSO

perl(1), PDL(3perl)

=cut

EOPM


# Always make sure that you finish your PP declarations with
# pp_done
pp_done();
##----------------------------------------------------------------------


##!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
## ccsops.pd: saved v2
##!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

##======================================================================
## Header Administrivia
##======================================================================

use PDL::VectorValued::Dev;
require "../Version.pm";
our $VERSION = $PDL::CCS::VERSION;
pp_setversion($VERSION);

##------------------------------------------------------
## pm headers
pp_addpm({At=>'Top'},<<'EOPM');

#use PDL::CCS::Version;
use strict;

=pod

=head1 NAME

PDL::CCS::Ops - Low-level binary operations for compressed storage sparse PDLs

=head1 SYNOPSIS

 use PDL;
 use PDL::CCS::Utils;

 ##---------------------------------------------------------------------
 ## ... stuff happens

=cut

EOPM
## /pm additions
##------------------------------------------------------

##------------------------------------------------------
## Exports: None
#pp_export_nothing();

##------------------------------------------------------
## Includes / defines
pp_addhdr(<<'EOH');

#include <math.h>

/*---- BEGIN macros lifted from $PDL_SRC_ROOT/Basic/Ops/ops.pd ---*/
/* MOD requires hackage to map properly into the positive-definite numbers. */
/* Note that this code causes some warning messages in the compile, because */
/* the unsigned data types always fail the ((foo)<0) tests.  I believe that */
/* gcc optimizes those tests away for those data types.  --CED 7-Aug-2002   */

#define MOD(X,N) (  ((N) == 0)   ?    0   :   (   (X) - (ABS(N))  *  ((int)((X)/(ABS(N))) + (   ( ((N) * ((int)((X)/(N)))) != (X) )   ?   ( ( ((N)<0) ? 1 : 0 )  +  ( (((X)<0) ? -1 : 0)))  :  0 ))))

#define SPACE(A,B)   ( ((A)<(B)) ? -1 : ((A)!=(B)) )
#define ABS(A)       ( (A)>=0 ? (A) : -(A) )
#define NOTHING
/*---- END macros lifted from $PDL_SRC_ROOT/Basic/Ops/ops.pd ---*/

EOH


##======================================================================
## C Utilities
##======================================================================
# (none)

##======================================================================
## PDL::PP Wrappers
##======================================================================


##======================================================================
## Operations: Binary: GENERIC
##======================================================================

## %vvpp_def_hash = ccs_binop_hash($op_codename, $op_docname, %args)
## + known %args
##    out_type        => $pptype_or_undef,   ##-- set type of output $nzvals (default: match input $nzvals)
##    out_type_perl   => $perlcode_or_undef, ##-- set output perl type (e.g. out_type_perl=>'PDL::long()')
##    opsub           => \&perl_sub,         ##-- called as $sub->($aval_str,$bval_str,$cval_str), returns pp code
##    cop             => $c_op_str,          ##-- default \&op_sub for C operations
##    init_code       => $ppcode_or_undef,   ##-- misc initialization
##    extra_doc       => $extra_doc,         ##-- additional documentation
##    extra           => \%extraPPArgs,      ##-- extra args for vvpp_def()
sub ccs_binop_hash {
  my ($op_codename,$op_docname,%args) = @_;
  my $cop = $args{cop};
  $args{opsub} = sub { "$_[2] = (($_[0]) ${cop} ($_[1]));" } if (defined($args{cop}));
  die ("ccs_binop_hash(): no opsub defined for op '$op_codename'!") if (!defined($args{opsub}));
  return
    (
     Pars => ("\n    "
	      .join("\n    ",
		    'int    ixa(Ndims,NnzA);    nza(NnzA);    missinga();',
		    'int    ixb(Ndims,NnzB);    nzb(NnzB);    missingb();',
		    (
		     'int [o]ixc(Ndims,NnzC);'
		     .(($args{out_type}||'').' [o]nzc(NnzC);')
		     .(($args{out_type}||'').' [o]missingc();')
		    ),
		    'int [o]nnzai_nxt(); int [o]nnzbi_nxt(); int [o]nnzci_nxt();',
		    '')),

   PMCode =>
('
 sub PDL::ccs_binop_'.${op_codename}.' {
   my ($ixa,$nza,$za, $ixb,$nzb,$zb, $ixc,$nzc,$zc, $nnzai_nxt,$nnzbi_nxt,$nnzci_nxt) = @_;
   ##
   ##-- init: get dimensions
   my ($ndimsA,$nnzA,@tdimsA) = $ixa->dims;
   my ($ndimsB,$nnzB,@tdimsB) = $ixb->dims;
   barf("PDL::ccs_binop_'.$op_codename.'(): no support for NdimsA!=NdimsB ($ndimsA!=$ndimsB)")
      if ($ndimsA != $ndimsB);
   barf("PDL::ccs_binop_'.$op_codename.'(): threaded dimension mismatch")
     if ($#tdimsA != $#tdimsB || grep {$tdimsA[$_] != $tdimsB[$_]} (0..$#tdimsA));
   my ($ndimsC,$nnzC,@tdimsC);
   if (defined($ixc)) {
     ($ndimsC,$nnzC,@tdimsC) = $ixc->dims;
   } else {
     $ndimsC=$ndimsA;
   }
   ($nnzC,@tdimsC) = $nzc->dims if (!defined($nnzC) && defined($nzc) && !$nzc->isempty);
   if (!defined($nnzC)) {
     $nnzC   = $nnzA+$nnzB;
     @tdimsC = @tdimsA;
   } else {
     ##-- sanity check
     barf("PDL::ccs_binop_'.$op_codename.'(): no support for NdimsA!=NdimsC ($ndimsA!=$ndimsC)")
       if ($ndimsA != $ndimsC);
     barf("PDL::ccs_binop_'.$op_codename.'(): threaded dimension mismatch")
       if ($#tdimsA != $#tdimsC || grep {$tdimsA[$_] != $tdimsC[$_]} (0..$#tdimsA));
   }
   ##
   ##-- allocate
   $ixc = PDL->zeroes(PDL::long(), $ndimsC,$nnzC,@tdimsC)
      if (!defined($ixc));
   $nzc = PDL->zeroes('.($args{out_type_perl}||'$nza->type').', $nnzC,@tdimsC)
      if (!defined($nzc));
   $zc  = PDL->zeroes($nzc->type, 1,@tdimsC)       if (!defined($zc));
   $nnzai_nxt = PDL->zeroes(PDL::long(),1,@tdimsC) if (!defined($nnzai_nxt));
   $nnzbi_nxt = PDL->zeroes(PDL::long(),1,@tdimsC) if (!defined($nnzbi_nxt));
   $nnzci_nxt = PDL->zeroes(PDL::long(),1,@tdimsC) if (!defined($nnzci_nxt));
   ##
   ##-- internal call
   &PDL::_ccs_binop_'.$op_codename.'_int($ixa,$nza,$za, $ixb,$nzb,$zb, $ixc,$nzc,$zc, $nnzai_nxt,$nnzbi_nxt,$nnzci_nxt);
   ##
   ##-- auto-trim
   my $trimto = $nnzci_nxt->max-1;
   $ixc = $ixc->slice(",0:$trimto");
   $nzc = $nzc->slice("0:$trimto");
   return wantarray ? ($ixc,$nzc,$zc) : $nzc;
 }
'),
   Code =>
(q(
 long nnzai, nnzbi, nnzci=0;
 long sizeNnzA=$SIZE(NnzA), sizeNnzB=$SIZE(NnzB), sizeNnzC=$SIZE(NnzC);
 int ixaval,ixbval,cmpval;
 $GENERIC(nzc) zvala, zvalb, zvalc, nzvalc;
 ).($args{decls}||'').q(
 //
 //-- init
 zvala = $missinga();
 zvalb = $missingb();
 ).$args{opsub}->('zvala','zvalb','zvalc').q(
 //
 //-- main loop
 for ( nnzai=0,nnzbi=0; nnzai<sizeNnzA && nnzbi<sizeNnzB && nnzci<sizeNnzC; ) {
   $CMPVEC('$ixa(NnzA=>nnzai)','$ixb(NnzB=>nnzbi)','Ndims','cmpval',var1=>'ixaval',var2=>'ixbval');
   if (cmpval < 0) {
     //-- CASE ixa(,ai) <  ixb(,bi) : INSERT ( ixa(,ai) => ixa(,ai)   ${OP} missingb() ); ai++;
     ).$args{opsub}->('$nza(NnzA=>nnzai)', 'zvalb', 'nzvalc').q(
     if (nzvalc != zvalc) {
       loop (Ndims) %{ $ixc(NnzC=>nnzci) = $ixa(NnzA=>nnzai); %}
       $nzc(NnzC=>nnzci) = nzvalc;
       nnzci++;
     }
     nnzai++;
   }
   else if (cmpval > 0) {
     //-- CASE ixa(,ai) >  ixb(,bi) : INSERT ( ixb(,bi) => missinga() ${OP} ixb(,bi)   );       bi++;
     ).$args{opsub}->('zvala', '$nzb(NnzB=>nnzbi)', 'nzvalc').q(
     if (nzvalc != zvalc) {
       loop (Ndims) %{ $ixc(NnzC=>nnzci) = $ixb(NnzB=>nnzbi); %}
       $nzc(NnzC=>nnzci) = nzvalc;
       nnzci++;
     }
     nnzbi++;
   }
   else { /*(cmpval == 0)*/
     //-- CASE ixa(,ai) == ixb(,bi) : INSERT ( ixa(,ai) => ixa(,ai)   ${OP} ixb(,bi)   ); ai++; bi++;
     ).$args{opsub}->('$nza(NnzA=>nnzai)', '$nzb(NnzB=>nnzbi)', 'nzvalc').q(
     if (nzvalc != zvalc) {
       loop (Ndims) %{ $ixc(NnzC=>nnzci) = $ixa(NnzA=>nnzai); %}
       $nzc(NnzC=>nnzci) = nzvalc;
       nnzci++;
     }
     nnzai++;
     nnzbi++;
   }
 }
 //
 //-- gobble remaining values from a()
 for ( ; nnzai<sizeNnzA && nnzci<sizeNnzC; nnzai++) {
   //-- CASE ixa(,ai) <  ixb(,bi) : INSERT ( ixa(,ai) => ixa(,ai)   ${OP} missingb() ); ai++;
   ).$args{opsub}->('$nza(NnzA=>nnzai)', 'zvalb', 'nzvalc').q(
   if (nzvalc != zvalc) {
     loop (Ndims) %{ $ixc(NnzC=>nnzci) = $ixa(NnzA=>nnzai); %}
     $nzc(NnzC=>nnzci) = nzvalc;
     nnzci++;
   }
 }
 //
 //-- gobble remaining values from b()
 for ( ; nnzbi<sizeNnzB && nnzci<sizeNnzC; nnzbi++) {
   //-- CASE ixa(,ai) >  ixb(,bi) : INSERT ( ixb(,bi) => missinga() ${OP} ixb(,bi)   );       bi++;
   ).$args{opsub}->('zvala', '$nzb(NnzB=>nnzbi)', 'nzvalc').q(
   if (nzvalc != zvalc) {
     loop (Ndims) %{ $ixc(NnzC=>nnzci) = $ixb(NnzB=>nnzbi); %}
     $nzc(NnzC=>nnzci) = nzvalc;
     nnzci++;
   }
 }
 //
 //-- set remaining output values
 $nnzai_nxt() = nnzai;
 $nnzbi_nxt() = nnzbi;
 $nnzci_nxt() = nnzci;
 $missingc() = zvalc;
 for ( ; nnzci<sizeNnzC; nnzci++) {
   loop (Ndims) %{ $ixc(NnzC=>nnzci) = -1; %}
   $nzc(NnzC=>nnzci) = zvalc;
 }
)),
  Doc =>
(q(
Binary ).${op_docname}.q( on sparse index-encoded PDLs.

The triples C<($ixa,$nza,$missinga)> and C<($ixb,$nzb,$missingb)> are treated as
index-encoded sparse C<Ndims>-dimensional data PDLs.  Both C<$ixa()> and C<$ixb()>
must be sorted in lexicographic order, i.e. according to the specifications for C<qsortvec()>.

On return, the triple
C<($ixc,$nzc,$missingc)> holds the result of the operation encoded as yet
another sparse index-encoded PDL such that C<NnzC> E<lt>= C<(NnzA+NnzB)>.
Missing values in either or both input triples should be handled correctly.

Returned values are automagically sliced on the C<NnzC> dimension
to the actual number of computed non-C<$missingc()> values in C<$nzc()>, by means of
the pseudo-temporary parameter C<$nnzci_nxt()>.
The index output parameters C<$nnzai_nxt()>, C<$nnzbi_nxt()>, and C<$nnzci_nxt()>
can be used for block-wise computation at the perl level, but are never explicitly returned:
if you need them, you must specify them yourself.  In such cases,
you should probably be calling PDL::_ccs_binop_).$op_codename.q(_int() directly anyways.

In scalar context, returns only C<$nzc()>.

)),
  ##
  ##-- extra user arguments
  ($args{extra} ? %{$args{extra}} : qw()),
 ); ##--/ccs_binop_hash: return
} ##--/ccs_binop_hash: sub

sub ccs_binop_def {
  vvpp_def(('ccs_binop_'.$_[0]), ccs_binop_hash(@_));
}

##--------------------------------------------------------------
## Binary Operations: arithmetic
ccs_binop_def('plus',   'addition',        cop=>'+');
ccs_binop_def('minus',  'subtraction',     cop=>'-');
ccs_binop_def('mult',   'multiplication',  cop=>'*');
ccs_binop_def('divide', 'division',        cop=>'/');
ccs_binop_def('modulo', 'modulo-division',  opsub=>sub{"$_[2]=MOD($_[0],$_[1]);"});
ccs_binop_def('power',  'potentiation (a**b)', opsub=>sub{"$_[2]=pow($_[0],$_[1]);"},   extra=>{GenericTypes=>['D']});
ccs_binop_def('atan2',  'atan2',           opsub=>sub{"$_[2]=atan2($_[0],$_[1]);"}, extra=>{GenericTypes=>['D']});

##--------------------------------------------------------------
## Binary Operations: comparisons
ccs_binop_def('gt', 'greater-than',           cop=>'>');
ccs_binop_def('ge', 'greater-than-or-equal',  cop=>'>=');
ccs_binop_def('lt', 'less-than',              cop=>'<');
ccs_binop_def('le', 'less-than-or-equal',     cop=>'<=');
ccs_binop_def('eq', 'equality',               cop=>'==');
ccs_binop_def('ne', 'inequality',             cop=>'!=');
ccs_binop_def('spaceship', '3-way comparison', opsub=>sub{"$_[2]=SPACE(($_[0]),($_[1]));"});

##--------------------------------------------------------------
## Binary Operations: logical & bitwise
my %int_only = ( extra=>{GenericTypes=>['B','U','S','L']} ); ##-- integer types
ccs_binop_def('and2',       'bitwise I<and> (a&b)',          cop=>'&',  %int_only);
ccs_binop_def('or2',        'bitwise I<or> (a|b)',           cop=>'|',  %int_only);
ccs_binop_def('xor',        'bitwise I<exclusive or> (a^b)', cop=>'^',  %int_only);
ccs_binop_def('shiftleft',  'bitwise left-shift (a<<b)',     cop=>'<<', %int_only);
ccs_binop_def('shiftright', 'bitwise right-shift (a>>b)',    cop=>'>>', %int_only);


##======================================================================
## IDEA:
##  ccs_binop_${OP}(int    ixa(NdimsA,NnzA),    nza(NnzA),    missinga(),
##                  int    ixb(NdimsB,NnzB),    nzb(NnzB),    missingb(),
##                  int [o]ixc(NdimsC,NnzC), [o]nzc(NnzC), [o]missingc())
##  + where:
##    - NdimsA==NdimsB==NdimsC  ##-- simple case: no (pseudo-)threading
##    - NnzC <= NnzA+NnzB       ##-- add auto-trimming in PMCode
##    - ixa() and ixb() are both sorted
##
##  + idea: basic algorithm
##    - traverse ixa(),ixb() in parallel (as for vv_union() & friends)
##    - dispatch at each position:
##      ~ CASE ixa(,ai) == ixb(,bi) : INSERT ( ixa(,ai) => ixa(,ai)   ${OP} ixb(,bi)   ); ai++; bi++;
##      ~ CASE ixa(,ai) <  ixb(,bi) : INSERT ( ixa(,ai) => ixa(,ai)   ${OP} missingb() ); ai++;
##      ~ CASE ixa(,ai) >  ixb(,bi) : INSERT ( ixb(,bi) => missinga() ${OP} ixb(,bi)   );       bi++;
##    - DO auto-detect "missingOut" values, e.g. add 'tmp_isgood' check
##
##  + extension: pseudo-threading
##    - idea: allow (NdimsA != NdimsB)
##      ~ generalize to highest order: set NdimsC = max(NdimsA,NdimsB)
##      ~ also allow PMCode to dispatch s.t. (NdimsB <= NdimsA)
##      ~ then, vector comparison is: ixa(0..(NdimsB-1),ai) <=> ixb(,bi)
##        * requires home-grown CMPVEC or extension of PDL::VectorValued $CMPVEC() macro
##        * this allows ixb() to thread over INITIAL dimensions (a la PDL threading)
##        * still doesn't generalize to VECTORS ~ dimension-mismatches where e.g. NdimsB(dimi)==1
##      ~ also wreaks havoc with the case-based increment strategy above:
##        * if (NdimsB < NdimsA), we might well have multiple matches on a single ixb(,bi)
##        * third insertion case may induce a dense matrix, b/c requires implicit iteration:
##             { insert( ixb(,bi) => missinga() ${OP} ixb(,bi) ); bi++ }
##          + this won't cut the sparse butter though, since ixb(,bi) ~= $ixb(,bi).cat_{di=1}^{NdimsA-NdimsB)(seq(di))
##      ~ maybe abstract "alignment" code (ixa(,ai)<=>ixb(,bi)) to its own function
##        and do the rest in perl?
##        * ccs_binop_align( ixa(), ixb(), int [o]ai(NnzC), int [o]bi(NnC) )
##          - here, we can use a constant (say, -1 or BAD) to indicate "no-match", e.g.
##              ai->isbad()   iff.   ixa(,ai) <  ixb(,bi)
##              bi->isbad()   iff.   ixa(,ai) >  ixb(,bi)
##          - maybe 'annihilator assumption' from compat vector-ops can save us ...

##======================================================================
## Footer Administrivia
##======================================================================

##------------------------------------------------------
## pm additions: footer
pp_addpm(<<'EOPM');

##---------------------------------------------------------------------
=pod

=head1 ACKNOWLEDGEMENTS

Perl by Larry Wall.

PDL by Karl Glazebrook, Tuomas J. Lukka, Christian Soeller, and others.

Some useful C macros copied verbatim from $PDL_SRC_ROOT/Basic/Ops/ops.pd.

=cut

##----------------------------------------------------------------------
=pod

=head1 KNOWN BUGS

No support for (pseudo)-threading.

=cut


##---------------------------------------------------------------------
=pod

=head1 AUTHOR

Bryan Jurish E<lt>moocow@ling.uni-potsdam.deE<gt>

=head2 Copyright Policy

C macros from $PDL_SRC_ROOT/Basic/Ops/ops.pd copyright
their respective authors.  See the file COPYING in the
PDL distribution for details.

All other parts Copyright (C) 2007, Bryan Jurish. All rights reserved.

This package is free software, and entirely without warranty.
You may redistribute it and/or modify it under the same terms
as Perl itself.

=head1 SEE ALSO

perl(1), PDL(3perl)

=cut

EOPM


# Always make sure that you finish your PP declarations with
# pp_done
pp_done();
##----------------------------------------------------------------------



##!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
## ccsops.pd: saved v1
##!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


##======================================================================
## Header Administrivia
##======================================================================

use PDL::VectorValued::Dev;
require "../Version.pm";
our $VERSION = $PDL::CCS::VERSION;
pp_setversion($VERSION);

##------------------------------------------------------
## pm headers
pp_addpm({At=>'Top'},<<'EOPM');

#use PDL::CCS::Version;
use strict;

=pod

=head1 NAME

PDL::CCS::Ops - Low-level binary operations for compressed storage sparse PDLs

=head1 SYNOPSIS

 use PDL;
 use PDL::CCS::Utils;

 ##---------------------------------------------------------------------
 ## ... stuff happens

=cut

EOPM
## /pm additions
##------------------------------------------------------

##------------------------------------------------------
## Exports: None
#pp_export_nothing();

##------------------------------------------------------
## Includes / defines
pp_addhdr(<<'EOH');
EOH


##======================================================================
## C Utilities
##======================================================================
# (none)

##======================================================================
## PDL::PP Wrappers
##======================================================================


##======================================================================
## Operations: Binary
##======================================================================

##--------------------------------------------------------------
## Operations: Binary: plus
vvpp_def
  ('ccs_binop_plus',
   Pars => ("\n    "
	    .join("\n    ",
		  'int    ixa(Ndims,NnzA);    nza(NnzA);    missinga();',
		  'int    ixb(Ndims,NnzB);    nzb(NnzB);    missingb();',
		  'int [o]ixc(Ndims,NnzC); [o]nzc(NnzC); [o]missingc(); int [o]nnzc();',
		  '')),
   PMCode =>
(q(
 sub PDL::ccs_binop_plus {
   my ($ixa,$nza,$za, $ixb,$nzb,$zb, $ixc,$nzc,$zc,$nnzc_out) = @_;
   ##
   ##-- init: get dimensions
   my ($ndimsA,$nnzA,@tdimsA) = $ixa->dims;
   my ($ndimsB,$nnzB,@tdimsB) = $ixb->dims;
   barf("PDL::ccs_binop_plus(): no support for NdimsA!=NdimsB ($ndimsA!=$ndimsB)") if ($ndimsA != $ndimsB);
   barf("PDL::ccs_binop_plus(): threaded dimension mismatch")
     if ($#tdimsA != $#tdimsB || grep {$tdimsA[$_] != $tdimsB[$_]} (0..$#tdimsA));
   my ($ndimsC,$nnzC,@tdimsC);
   if (defined($ixc)) {
     ($ndimsC,$nnzC,@tdimsC) = $ixc->dims;
   } else {
     $ndimsC=$ndimsA;
   }
   ($nnzC,@tdimsC) = $nzc->dims if (!defined($nnzC) && defined($nzc) && !$nzc->isempty);
   if (!defined($nnzC)) {
     $nnzC   = $nnzA+$nnzB;
     @tdimsC = @tdimsA;
   } else {
     ##-- sanity check
     barf("PDL::ccs_binop_plus(): no support for NdimsA!=NdimsC ($ndimsA!=$ndimsC)") if ($ndimsA != $ndimsC);
     barf("PDL::ccs_binop_plus(): threaded dimension mismatch")
       if ($#tdimsA != $#tdimsC || grep {$tdimsA[$_] != $tdimsC[$_]} (0..$#tdimsA));
   }
   ##
   ##-- allocate
   $ixc      = PDL->zeroes(PDL::long(), $ndimsC,$nnzC,@tdimsC) if (!defined($ixc));
   $nzc      = PDL->zeroes($nza->type, $nnzC,@tdimsC)          if (!defined($nzc));
   $zc       = PDL->zeroes($nzc->type, 1)                      if (!defined($zc));
   $nnzc_out = PDL->pdl(PDL::long(), 0)                        if (!defined($nnzc_out));
   ##
   ##-- internal call
   &PDL::_ccs_binop_plus_int($ixa,$nza,$za, $ixb,$nzb,$zb, $ixc,$nzc,$zc, $nnzc_out);
   ##
   ##-- auto-trim
   my $trimto = $nnzc_out->max-1;
   $ixc = $ixc->slice(",0:$trimto");
   $nzc = $nzc->slice("0:$trimto");
   return wantarray ? ($ixc,$nzc,$zc,$nnzc_out) : $nzc;
 }
)),
   Code =>
(q(
 long nnzai, nnzbi, nnzci=0;
 long sizeNnzA=$SIZE(NnzA), sizeNnzB=$SIZE(NnzB), sizeNnzC=$SIZE(NnzC);
 int ixaval,ixbval,cmpval;
 $GENERIC() zvala, zvalb, zvalc; //-- missing values
 $GENERIC() nzvalc;              //-- temporary
 //
 //-- init
 zvala = $missinga();
 zvalb = $missingb();
 zvalc = zvala + zvalb;
 //
 //-- main loop
 for ( nnzai=0,nnzbi=0; nnzai<sizeNnzA && nnzbi<sizeNnzB && nnzci<sizeNnzC; ) {
   $CMPVEC('$ixa(NnzA=>nnzai)','$ixb(NnzB=>nnzbi)','Ndims','cmpval',var1=>'ixaval',var2=>'ixbval');
   if (cmpval < 0) {
     //-- CASE ixa(,ai) <  ixb(,bi) : INSERT ( ixa(,ai) => ixa(,ai)   ${OP} missingb() ); ai++;
     nzvalc = $nza(NnzA=>nnzai) + zvalb;
     if (nzvalc != zvalc) {
       loop (Ndims) %{ $ixc(NnzC=>nnzci) = $ixa(NnzA=>nnzai); %}
       $nzc(NnzC=>nnzci) = nzvalc;
       nnzci++;
     }
     nnzai++;
   }
   else if (cmpval > 0) {
     //-- CASE ixa(,ai) >  ixb(,bi) : INSERT ( ixb(,bi) => missinga() ${OP} ixb(,bi)   );       bi++;
     nzvalc = zvala + $nzb(NnzB=>nnzbi);
     if (nzvalc != zvalc) {
       loop (Ndims) %{ $ixc(NnzC=>nnzci) = $ixb(NnzB=>nnzbi); %}
       $nzc(NnzC=>nnzci) = nzvalc;
       nnzci++;
     }
     nnzbi++;
   }
   else { /*(cmpval == 0)*/
     //-- CASE ixa(,ai) == ixb(,bi) : INSERT ( ixa(,ai) => ixa(,ai)   ${OP} ixb(,bi)   ); ai++; bi++;
     nzvalc = $nza(NnzA=>nnzai) + $nzb(NnzB=>nnzbi);
     if (nzvalc != zvalc) {
       loop (Ndims) %{ $ixc(NnzC=>nnzci) = $ixa(NnzA=>nnzai); %}
       $nzc(NnzC=>nnzci) = nzvalc;
       nnzci++;
     }
     nnzai++;
     nnzbi++;
   }
 }
 //
 //-- gobble remaining values from a()
 for ( ; nnzai<sizeNnzA && nnzci<sizeNnzC; nnzai++) {
   //-- CASE ixa(,ai) <  ixb(,bi) : INSERT ( ixa(,ai) => ixa(,ai)   ${OP} missingb() ); ai++;
   nzvalc = $nza(NnzA=>nnzai) + zvalb;
   if (nzvalc != zvalc) {
     loop (Ndims) %{ $ixc(NnzC=>nnzci) = $ixa(NnzA=>nnzai); %}
     $nzc(NnzC=>nnzci) = nzvalc;
     nnzci++;
   }
 }
 //
 //-- gobble remaining values from b()
 for ( ; nnzbi<sizeNnzB && nnzci<sizeNnzC; nnzbi++) {
   //-- CASE ixa(,ai) >  ixb(,bi) : INSERT ( ixb(,bi) => missinga() ${OP} ixb(,bi)   );       bi++;
   nzvalc = zvala + $nzb(NnzB=>nnzbi);
   if (nzvalc != zvalc) {
     loop (Ndims) %{ $ixc(NnzC=>nnzci) = $ixb(NnzB=>nnzbi); %}
     $nzc(NnzC=>nnzci) = nzvalc;
     nnzci++;
   }
 }
 //
 //-- set remaining output values
 $nnzc()     = nnzci;
 $missingc() = zvalc;
 for ( ; nnzci<sizeNnzC; nnzci++) {
   loop (Ndims) %{ $ixc(NnzC=>nnzci) = -1; %}
   $nzc(NnzC=>nnzci) = zvalc;
 }
)),
  ); ##-- /ccs_binop_plus

## IDEA:
##  ccs_binop_${OP}(int    ixa(NdimsA,NnzA),    nza(NnzA),    missinga(),
##                  int    ixb(NdimsB,NnzB),    nzb(NnzB),    missingb(),
##                  int [o]ixc(NdimsC,NnzC), [o]nzc(NnzC), [o]missingc())
##  + where:
##    - NdimsA==NdimsB==NdimsC  ##-- simple case: no (pseudo-)threading
##    - NnzC <= NnzA+NnzB       ##-- add auto-trimming in PMCode
##    - ixa() and ixb() are both sorted
##
##  + idea: basic algorithm
##    - traverse ixa(),ixb() in parallel (as for vv_union() & friends)
##    - dispatch at each position:
##      ~ CASE ixa(,ai) == ixb(,bi) : INSERT ( ixa(,ai) => ixa(,ai)   ${OP} ixb(,bi)   ); ai++; bi++;
##      ~ CASE ixa(,ai) <  ixb(,bi) : INSERT ( ixa(,ai) => ixa(,ai)   ${OP} missingb() ); ai++;
##      ~ CASE ixa(,ai) >  ixb(,bi) : INSERT ( ixb(,bi) => missinga() ${OP} ixb(,bi)   );       bi++;
##    - DO auto-detect "missingOut" values, e.g. add 'tmp_isgood' check
##
##  + extension: pseudo-threading
##    - idea: allow (NdimsA != NdimsB)
##      ~ generalize to highest order: set NdimsC = max(NdimsA,NdimsB)
##      ~ also allow PMCode to dispatch s.t. (NdimsB <= NdimsA)
##      ~ then, vector comparison is: ixa(0..(NdimsB-1),ai) <=> ixb(,bi)
##        * requires home-grown CMPVEC or extension of PDL::VectorValued $CMPVEC() macro
##        * this allows ixb() to thread over INITIAL dimensions (a la PDL threading)
##        * still doesn't generalize to VECTORS ~ dimension-mismatches where e.g. NdimsB(dimi)==1
##      ~ also wreaks havoc with the case-based increment strategy above:
##        * if (NdimsB < NdimsA), we might well have multiple matches on a single ixb(,bi)
##        * third insertion case may induce a dense matrix, b/c requires implicit iteration:
##             { insert( ixb(,bi) => missinga() ${OP} ixb(,bi) ); bi++ }
##          + this won't cut the sparse butter though, since ixb(,bi) ~= $ixb(,bi).cat_{di=1}^{NdimsA-NdimsB)(seq(di))
##      ~ maybe abstract "alignment" code (ixa(,ai)<=>ixb(,bi)) to its own function
##        and do the rest in perl?
##        * ccs_binop_align( ixa(), ixb(), int [o]ai(NnzC), int [o]bi(NnC) )
##          - here, we can use a constant (say, -1 or BAD) to indicate "no-match", e.g.
##              ai->isbad()   iff.   ixa(,ai) <  ixb(,bi)
##              bi->isbad()   iff.   ixa(,ai) >  ixb(,bi)
##          - maybe 'annihilator assumption' from compat vector-ops can save us ...

##======================================================================
## Footer Administrivia
##======================================================================

##------------------------------------------------------
## pm additions: footer
pp_addpm(<<'EOPM');

##---------------------------------------------------------------------
=pod

=head1 ACKNOWLEDGEMENTS

Perl by Larry Wall.

PDL by Karl Glazebrook, Tuomas J. Lukka, Christian Soeller, and others.

=cut

##----------------------------------------------------------------------
=pod

=head1 KNOWN BUGS

Probably many.

=cut


##---------------------------------------------------------------------
=pod

=head1 AUTHOR

Bryan Jurish E<lt>moocow@ling.uni-potsdam.deE<gt>

=head2 Copyright Policy

Copyright (C) 2007, Bryan Jurish. All rights reserved.

This package is free software, and entirely without warranty.
You may redistribute it and/or modify it under the same terms
as Perl itself.

=head1 SEE ALSO

perl(1), PDL(3perl)

=cut

EOPM


# Always make sure that you finish your PP declarations with
# pp_done
pp_done();
##----------------------------------------------------------------------
