##-*- Mode: CPerl -*-

##======================================================================
## Header Administrivia
##======================================================================

use PDL::VectorValued::Dev;
require "../Version.pm";
our $VERSION = $PDL::CCS::VERSION;
pp_setversion($VERSION);

##------------------------------------------------------
## pm headers
pp_addpm({At=>'Top'},<<'EOPM');

#use PDL::CCS::Version;
use strict;

=pod

=head1 NAME

PDL::CCS::Utils - Low-level utilities for compressed storage sparse PDLs

=head1 SYNOPSIS

 use PDL;
 use PDL::CCS::Utils;

 ##---------------------------------------------------------------------
 ## ... stuff happens

=cut

EOPM
## /pm additions
##------------------------------------------------------

##------------------------------------------------------
## Exports: None
#pp_export_nothing();

##------------------------------------------------------
## Includes / defines
pp_addhdr(<<'EOH');
EOH


##======================================================================
## C Utilities
##======================================================================
# (none)

##======================================================================
## PDL::PP Wrappers
##======================================================================


##======================================================================
## Non-missing Value Counts
##======================================================================

pp_addpm(<<'EOPM');

=pod

=head1 Non-missing Value Counts

=cut

EOPM

##------------------------------------------------------
## nnz() : get number of nonzero values
pp_def('nnz',
       Pars => 'a(N); int+ [o]nnz()',
       Code =>
('
  $nnz()=0;
  loop (N) %{
    if ($a()!=0) ++$nnz();
  %}
'),
       Doc =>
q(Get number of non-zero values in a PDL $a();
For 1d PDLs, should be equivalent to:

 $nnz = nelem(which($a!=0));

For k>1 dimensional PDLs, projects via number of nonzero elements
to N-1 dimensions by computing the number of nonzero elements
along the the 1st dimension.
),
      );

##------------------------------------------------------
## nnza() : get number of non-approximate zero values
pp_def('nnza',
       Pars => 'a(N); eps(); int+ [o]nnz()',
       Code => ('$nnz()=0; loop (N) %{ if (abs($a()) > $eps()) ++$nnz(); %}'),
       Doc =>
q(Like nnz() using tolerance constant $eps().
For 1d PDLs, should be equivalent to:

 $nnz = nelem(which(!$a->approx(0,$eps)));
),
      );


##------------------------------------------------------
## ngoodover() : get number of good values: BUILTIN in PDL::Bad
#pp_def('ngoodover',
#       Pars => 'a(N); int+ [o]ngood()',
#       Code => '$ngood() = $SIZE(N);',
#       HandleBad=>1,
#       BadCode=>
#('
#  $GENERIC(a) a_val;
#  threadloop %{
#   $GENERIC(ngood) ngoodi = 0;
#   loop(N) %{
#    a_val = $a();
#    if ( $ISGOODVAR(a_val,a) ) { ++ngoodi; }
#   %}
#   $ngood() = ngoodi;
#  %}
#'),
#       CopyBadStatusCode => '$SETPDLSTATEGOOD(ngood); /* always make sure the output is "good" */',
#       BadDoc=>'The output PDL $ngood() always has its bad flag cleared.',
#       Doc =>
#q(Get number of good elements in a PDL $a();
#For 1d PDLs, should be equivalent to:
#
# $ngood = nelem(which($a->isgood()));
#
#For k>1 dimensional PDLs, projects via number of good elements
#to N-1 dimensions by computing the number of good elements
#along the the 1st dimension.
#),
#      );



##======================================================================
## Encoding
##======================================================================

pp_addpm(<<'EOPM');

=pod

=head1 Encoding Utilities

=cut

EOPM

##------------------------------------------------------
## ccs_encode_pointers() : get LENGTH-encoded pointer & index translation PDL
pp_def
  ('ccs_encode_pointers',
   Pars => 'int ix(Nnz); int N(); int [o]ptr(Nplus1); int [o]ixix(Nnz);',
   PMCode=>
(q{
 sub PDL::ccs_encode_pointers {
   my ($ix,$N,$ptr,$ixix) = @_;
   barf("Usage: ccs_encode_pointers(ix(Nnz), N(), [o]ptr(N), [o]ixix(Nnz)") if (!defined($ix));
   $N    = $ix->max()+1                               if (!defined($N));
   $ptr = PDL->zeroes(PDL::long(), $N+1)              if (!defined($ptr));
   $ixix = PDL->zeroes(PDL::long(), $ix->dim(0))      if (!defined($ixix));
   &PDL::_ccs_encode_pointers_int($ix,$N,$ptr,$ixix);
   return ($ptr,$ixix);
 }
}),
   Code =>
(q(
 /*-- Local variables --*/
 long ixval, ixval_next, ixval_prev, nzi, nzj, sizeN=$SIZE(Nplus1)-1, sizeNnz=$SIZE(Nnz);
 //
 /*-- Count number of NZs in each column; store in ptr[N=>ixval] --*/
 loop (Nplus1) %{ $ptr()=0; %}
 loop (Nnz)    %{ ixval=$ix(); ++$ptr(Nplus1=>ixval); %}
 //
 /*-- tweak ptr(): fill each cell with the starting point of the previous row --*/
 ixval_prev = sizeN-1;
 $ptr(Nplus1=>sizeN) = sizeNnz - $ptr(Nplus1=>ixval_prev);
 for (ixval_next=sizeN, ixval=ixval_prev; ixval > 0; ixval_next=ixval--) {
   ixval_prev = ixval-1;
   $ptr(Nplus1=>ixval) = $ptr(Nplus1=>ixval_next) - $ptr(Nplus1=>ixval_prev);
 }
 $ptr(Nplus1=>0) = 0;
 //
 /*-- Assign columns and values --*/
 for (nzi=0; nzi < sizeNnz; nzi++) {
   ixval      = $ix(Nnz=>nzi);
   ixval_next = ixval+1;
   nzj        = $ptr(Nplus1=>ixval_next)++;
   $ixix(Nnz=>nzj) = nzi;
 }
)),
  Doc=><<'EOD'
General CCS encoding utility.

Get a compressed storage "pointer" vector $ptr
for a dimension of size $N with non-missing values at indices $ix.  Also returns a vector
$ixix() which may be used as an index for $ix() to align its elements with $ptr()
along the compressed dimension.

The induced vector $ix-E<gt>index($ixix) is
guaranteed to be stably sorted along dimension $N():

 \forall $i,$j with 1 <= $i < $j <= $Nnz :

  $ix->index($ixix)->at($i) < $ix->index($ixix)->at($j)   ##-- primary sort on $ix()
 or
  $ixix->at($i)             < $ixix->at($j)               ##-- ... stable

EOD
  );


##======================================================================
## Decoding
##======================================================================
pp_addpm(<<'EOPM');

=pod

=head1 Decoding Utilities

=cut

EOPM

##------------------------------------------------------
## ccs_decode_pointer() : decode a CCS-encoded pointer
pp_def
  ('ccs_decode_pointer',
   Pars => 'int ptr(Nplus1); int proj(Nproj); int [o]projix(NnzProj); int [o]nzix(NnzProj)',
   PMCode=>
(q{
 sub PDL::ccs_decode_pointer {
   my ($ptr,$proj,$projix,$nzix) = @_;
   barf("Usage: ccs_decode_pointer(ptr(N+1), proj(Nproj), [o]projix(NnzProj), [o]nzix(NnzProj)")
     if (!defined($ptr));
   my ($nnzproj);
   if (!defined($proj)) {
     $proj    = PDL->sequence(PDL::long(), $ptr->dim(0)-1);
     $nnzproj = $ptr->at(-1);
   }
   if (!defined($projix) || !defined($nzix)) {
     $nnzproj = ($ptr->index($proj+1)-$ptr->index($proj))->sum if (!defined($nnzproj));
     $projix  = PDL->zeroes(PDL::long(), $nnzproj) if (!defined($projix));
     $nzix    = PDL->zeroes(PDL::long(), $nnzproj) if (!defined($nzix));
   }
   &PDL::_ccs_decode_pointer_int($ptr,$proj,$projix,$nzix);
   return ($projix,$nzix);
 }
}),
   Code =>
(q(
 /*-- Local variables --*/
 long ni,ni_next, nzi,nzi_next, ixi=0, sizeNproj=$SIZE(Nproj), sizeNnzProj=$SIZE(NnzProj);
 loop (Nproj) %{
   ni         = $proj();
   ni_next    = ni+1;
   nzi        = $ptr(Nplus1=>ni);
   nzi_next   = $ptr(Nplus1=>ni_next);
   for ( ; nzi < nzi_next && ixi < sizeNnzProj; nzi++, ixi++) {
     $projix(NnzProj=>ixi) = Nproj;
     $nzix(NnzProj=>ixi)   = nzi;
   }
 %}
)),
  Doc=><<'EOD'
General CCS decoding utility.

Project indices $proj() from a compressed storage "pointer" vecotr $proj().
If unspecified, $proj() defaults to:

 sequence($ptr->dim(0))

EOD
  );


##======================================================================
## Operations: Accumulators (Ufuncs)
##======================================================================
pp_addpm(<<'EOPM');

=pod

=head1 Ufuncs (Accumulators)

=cut

EOPM

##--------------------------------------------------------------
## Operations: Accumulators (Ufuncs): Generic

## %vvpp_def_hash = ccs_accum_hash($op_codename, $op_docname, %args)
## + known %args
##    out_type        => $pptype_or_undef,   ##-- set type of output $nzvals (default: match input $nzvals)
##    out_type_perl   => $perlcode_or_undef, ##-- set output perl type
##    init_missingOut => $ppcode_or_undef,   ##-- sets value missingOut: default: 'missingOut=$missing();'
##    init_code       => $ppcode_or_undef,   ##-- misc initialization
##    tmp_type        => $ppcode_or_undef,   ##-- default: $GENERIC(nzvalsOut)
##    tmp_addmissing  => $ppcode_or_undef,   ##-- updates C var 'tmp' before insertion (may reference nMissing)
##    #tmp_isgood     => $ppcode_or_undef,  ##-- if defined, checks whether C var (tmp) should be considered "good"
##    tmp_addval      => $ppcode_or_undef,   ##-- add PP value $nzvalsIn(NnzIn=>nnzii) to tmp
##    tmp_reset       => $ppcode_or_undef,   ##-- reset tmp on index change (default: tmp=$nzvalsIn(NnzIn=>nnzii)) --> QUITE USELESS
##    doc_addmissing  => $addmissing_doc,    ##-- doc for 'addmissing'
##    extra           => \%extraPPArgs,      ##-- extra args for vvpp_def()
sub ccs_accum_hash {
  my ($op_codename,$op_docname,%args) = @_;
  return
    (
  Pars => ("\n    "
	   .join(";\n    ",
		 'int ixIn(Ndims,NnzIn)',      ##-- sorted nz-indices of projected dimensions (1..Ndims), with repeats
		 'nzvalsIn(NnzIn)',            ##-- all nz-values
		 'missing()',                  ##-- missing value         (default: $PDL::undefval (0))
		 'int N()',                    ##-- size of 0th dimension (<=0 to ignore missing values)
		 'int [o]ixOut(Ndims,NnzOut)', ##-- unique indices of projected dimensions
		 (
		  ($args{out_type} ? ($args{out_type}.' ') : '   ').'[o]nzvalsOut(NnzOut)'
		 ),		               ##-- unique nz-values of projected dims which contain >=1 input nz
		 'int [o]nOut()',              ##-- number of unique output index-vectors
		 '')),
     PMCode =>
(q(
 sub PDL::ccs_accum_).${op_codename}.q( {
   my ($ixIn,$nzvalsIn, $missing,$N, $ixOut,$nzvalsOut,$nOut) = @_;
   my ($ndims,@nnzIn) = $ixIn->dims;
   my (@nnzOut);
   if (defined($ixOut)) {
     @nnzOut = $ixOut->dims;
     shift(@nnzOut);
   }
   @nnzOut = $nzvalsOut->dims if (!@nnzOut && defined($nzvalsOut) && !$nzvalsOut->isempty);
   @nnzOut = @nnzIn           if (!@nnzOut);
   $ixOut  = PDL->zeroes(PDL::long(), $ndims,@nnzOut)
     if (!defined($ixOut)      || $ixOut->isempty);
).'
   $nzvalsOut = PDL->zeroes('.($args{out_type_perl}||'$nzvalsIn->type').', @nnzOut)
     if (!defined($nzvalsOut) || $nzvalsOut->isempty);
'.q(
   $nOut = PDL->pdl(PDL::long(),0)                  if (!defined($nOut) || $nOut->isempty);
   ##
   ##-- guts
   &PDL::_ccs_accum_).${op_codename}.q(_int($ixIn,$nzvalsIn, $missing,$N, $ixOut,$nzvalsOut,$nOut);
   ##
   ##-- auto-trim
   $ixOut      = $ixOut->slice(",0:".($nOut-1));
   $nzvalsOut  = $nzvalsOut->slice("0:".($nOut-1));
   ##
   ##-- return
   return wantarray ? ($ixOut,$nzvalsOut,$nOut) : $nzvalsOut;
 }
)),
	   Code =>
(q(
 long nnzii_prev, nnzii, nnzoi=0;
 long sizeNnzIn=$SIZE(NnzIn), sizeNnzOut=$SIZE(NnzOut), nMissing, nMissingInit;
 int ival1,ival2,cmpval, carp_unsorted=0;
 $GENERIC(nzvalsOut) missingOut;
 $GENERIC(missing)   missingVal;
 ).($args{decls}    ? $args{decls}    : '').q(
 ).($args{tmp_type} ? $args{tmp_type} : '$GENERIC(nzvalsOut)').q( tmp;
 //
 //-- init
 ).($args{init_code}||'').q(
 ).($args{init_missingOut} || 'missingOut = $missing();').q(
 missingVal   = $missing();
 nMissingInit = $N()-1;
 nMissing     = nMissingInit;
 tmp          = $nzvalsIn(NnzIn=>0);
 //
 //-- loop
 for (nnzii_prev=0,nnzii=1; nnzii<sizeNnzIn && nnzoi<sizeNnzOut; nnzii_prev=nnzii++) {
   $CMPVEC('$ixIn(NnzIn=>nnzii)','$ixIn(NnzIn=>nnzii_prev)','Ndims','cmpval',var1=>'ival1',var2=>'ival2');
   if (cmpval > 0) {
     //-- CASE: ix > ix_prev : insert accumulated value
     ).($args{tmp_addmissing}||0).q(
     //-- always insert output value
     loop (Ndims) %{ $ixOut(NnzOut=>nnzoi) = $ixIn(NnzIn=>nnzii_prev); %}
     $nzvalsOut(NnzOut=>nnzoi) = tmp;
     nnzoi++;
     //
     // ... and reset temps
     ).(defined($args{tmp_reset}) ? $args{tmp_reset} :  'tmp = $nzvalsIn(NnzIn=>nnzii);').q( /* reset tmp */
     nMissing = nMissingInit;
   }
   else if (cmpval <= 0) {
     // CASE: ix >= ix_prev : accumulate to temps
     ).($args{tmp_addval}||'').q(;
     nMissing--;
     if (cmpval < 0) { carp_unsorted=1; } /*-- CASE: ix < ix_prev : GARBAGE (treat as equal) --*/
   }
 }
 //
 //-- sanity check).'
 if (nnzii<sizeNnzIn) {
   warn("PDL::ccs_accum_'.${op_codename}.'(): too few output values provided: some input values were ignored");
 }'.q(
 //
 //-- set final computed output values
 ).($args{tmp_addmissing}||'').q(
 loop (Ndims) %{ $ixOut(NnzOut=>nnzoi) = $ixIn(NnzIn=>nnzii_prev); %}
 $nzvalsOut(NnzOut=>nnzoi) = tmp;
 nnzoi++;
 $nOut() = nnzoi;
 //
 //-- set any remaining output values to 0 (indices) or "N*missing" (values)
 for ( ; nnzoi<sizeNnzOut; nnzoi++) {
   loop (Ndims) %{ $ixOut(NnzOut=>nnzoi) = 0; %}
   $nzvalsOut(NnzOut=>nnzoi) = missingOut;
 }
 //
 //-- carp?).'
 if (carp_unsorted) {
   warn("PDL::ccs_accum_'.${op_codename}.'(): unsorted input vector list detected: output will be incorrect");
 }'.q(
 //-- END
)),
	   Doc =>
(q(
Accumulated ).${op_docname}.q( over values $nzvalsIn() associated with vector-valued keys $ixIn().
On return,
$ixOut() holds the unique non-"missing" values of $ixIn(),
$nzvalsOut() holds the associated values,
and
$nOut() stores the number of unique non-missing values computed.

).($args{doc_addmissing}||'').q(

Returned PDLs are implicitly sliced such that NnzOut==$nOut().

In scalar context, returns only $nzvalsOut().

)),
  ($args{extra} ? %{$args{extra}} : qw()),
  ); ##--/ccs_accum_hash: return
} ##--/ccs_accum_hash: sub

sub ccs_accum_def {
  vvpp_def(('ccs_accum_'.$_[0]), ccs_accum_hash(@_));
}


##--------------------------------------------------------------
## Operations: Accumulators (Ufuncs): prod
ccs_accum_def('prod', 'product',
	      init_missingOut=>'if ($N() > 0) { missingOut = pow(missingVal, $N()); } else { missingOut = missingVal; }',
	      tmp_addmissing =>'if (nMissing > 0) { tmp *= pow(missingVal, nMissing); }',
	      #tmp_isgood     =>'tmp != missingOut',
	      tmp_addval     =>'tmp *= $nzvalsIn(NnzIn=>nnzii);',
	      doc_addmissing => <<'EOMD',

If $N() is specified and greater than zero, then the quantity:

 $missing ** ($N - (rlevec($ixIn))[0])

is multiplied into $nzvalsOut: this is probably What You Want if you are computing the product over a virtual
dimension in a sparse index-encoded PDL (see PDL::CCS::Nd for a wrapper class).

EOMD
	     );

##--------------------------------------------------------------
## Operations: Accumulators (Ufuncs): dprod
ccs_accum_def('dprod', 'double-precision product',
	      out_type       =>'double',
	      out_type_perl  =>'PDL::double()',
	      init_missingOut=>'if ($N() > 0) { missingOut = pow(missingVal, $N()); } else { missingOut = missingVal; }',
	      tmp_addmissing =>'if (nMissing > 0) { tmp *= pow(missingVal, nMissing); }',
	      #tmp_isgood     =>'tmp != missingOut',
	      tmp_addval     =>'tmp *= $nzvalsIn(NnzIn=>nnzii);',
	      doc_addmissing => <<'EOMD',

If $N() is specified and greater than zero, then the quantity:

 $missing ** ($N - (rlevec($ixIn))[0])

is multiplied into $nzvalsOut: this is probably What You Want if you are computing the product over a virtual
dimension in a sparse index-encoded PDL (see PDL::CCS::Nd for a wrapper class).

EOMD
	     );


##--------------------------------------------------------------
## Operations: Accumulators (Ufuncs): sum
ccs_accum_def('sum', 'sum',
	      init_missingOut=>'if ($N() > 0) { missingOut = $N() * missingVal; } else { missingOut = missingVal; }',
	      tmp_addmissing =>'if (nMissing > 0) { tmp += nMissing * missingVal; }',
	      #tmp_isgood     =>'tmp != missingOut',
	      tmp_addval     =>'tmp += $nzvalsIn(NnzIn=>nnzii);',
	      doc_addmissing => <<'EOMD',

If $N() is specified and greater than zero, then the quantity:

 $missing * ($N - (rlevec($ixIn))[0])

is added to $nzvalsOut: this is probably What You Want if you are summing over a virtual
dimension in a sparse index-encoded PDL (see PDL::CCS::Nd for a wrapper class).

EOMD
	     );

##--------------------------------------------------------------
## Operations: Accumulators (Ufuncs): dsum
ccs_accum_def('dsum', 'double-precision sum',
	      out_type       =>'double',
	      out_type_perl  =>'PDL::double()',
	      init_missingOut=>'if ($N() > 0) { missingOut = $N() * missingVal; } else { missingOut = missingVal; }',
	      tmp_addmissing =>'if (nMissing > 0) { tmp += nMissing * missingVal; }',
	      #tmp_isgood     =>'tmp != missingOut',
	      tmp_addval     =>'tmp += $nzvalsIn(NnzIn=>nnzii);',
	      doc_addmissing => <<'EOMD',

If $N() is specified and greater than zero, then the quantity:

 $missing * ($N - (rlevec($ixIn))[0])

is added to $nzvalsOut: this is probably What You Want if you are summing over a virtual
dimension in a sparse index-encoded PDL (see PDL::CCS::Nd for a wrapper class).

EOMD
	     );


##--------------------------------------------------------------
## Operations: Accumulators (Ufuncs): or
ccs_accum_def('or', 'logical "or"',
	      extra          => {GenericTypes => ['B','S','U','L'] },
	      tmp_type       => 'char',
	      init_missingOut=>'missingOut = missingVal;',
	      tmp_addmissing =>'if (nMissing > 0) { tmp = tmp || missingVal; }   if (tmp) tmp=1; /* canonicalize */',
	      tmp_addval     =>'tmp = tmp || $nzvalsIn(NnzIn=>nnzii);',
	      doc_addmissing => <<'EOMD',

If $N() is specified and greater than zero, $missing() is logically (or)ed
into each result value at each output index with a run length of less than $N() in $ixIn().
This is probably What You Want.

EOMD
	     );


##--------------------------------------------------------------
## Operations: Accumulators (Ufuncs): and
ccs_accum_def('and', 'logical "and"',
	      extra          => {GenericTypes => ['B','S','U','L'] },
	      tmp_type       => 'char',
	      init_missingOut=>'missingOut = missingVal;',
	      tmp_addmissing =>'if (nMissing > 0) { tmp = tmp && missingVal; }   if (tmp) tmp=1; /* canonicalize */',
	      tmp_addval     =>'tmp = tmp && $nzvalsIn(NnzIn=>nnzii);',
	      doc_addmissing => <<'EOMD',

If $N() is specified and greater than zero, $missing() is logically (and)ed
into each result value at each output index with a run length of less than $N() in $ixIn().
This is probably What You Want.

EOMD
	     );

##--------------------------------------------------------------
## Operations: Accumulators (Ufuncs): bor
ccs_accum_def('bor', 'bitwise "or"',
	      extra          => {GenericTypes => ['B','S','U','L'] },
	      init_missingOut=>'missingOut = missingVal;',
	      tmp_addmissing =>'if (nMissing > 0) { tmp = tmp | missingVal; }',
	      tmp_addval     =>'tmp |= $nzvalsIn(NnzIn=>nnzii);',
	      doc_addmissing => <<'EOMD',

If $N() is specified and greater than zero, $missing() is bitwise (or)ed
into each result value at each output index with a run length of less than $N() in $ixIn().
This is probably What You Want.

EOMD
	     );


##--------------------------------------------------------------
## Operations: Accumulators (Ufuncs): band
ccs_accum_def('band', 'bitwise "and"',
	      extra          => {GenericTypes => ['B','S','U','L'] },
	      init_missingOut=>'missingOut = missingVal;',
	      tmp_addmissing =>'if (nMissing > 0) { tmp &= missingVal; }',
	      tmp_addval     =>'tmp &= $nzvalsIn(NnzIn=>nnzii);',
	      doc_addmissing => <<'EOMD',

If $N() is specified and greater than zero, $missing() is bitwise (and)ed
into each result value at each output index with a run length of less than $N() in $ixIn().
This is probably What You Want.

EOMD
	     );

##--------------------------------------------------------------
## Operations: Accumulators (Ufuncs): maximum
ccs_accum_def('maximum', 'maximum',
	      decls          =>'$GENERIC(nzvalsIn) curval;',
	      init_missingOut=>'missingOut = missingVal;',
	      tmp_addmissing =>'if (nMissing > 0 && missingVal > tmp) { tmp = missingVal; }',
	      tmp_addval     =>'curval=$nzvalsIn(NnzIn=>nnzii); if (curval>tmp) tmp=curval;',
	      doc_addmissing => <<'EOMD',

If $N() is specified and greater than zero,
and if $missing() is greater than any listed value for a vector key with a run-length
of less than $N(), then $missing() is used as the output value for that key.
This is probably What You Want.

EOMD
	     );

##--------------------------------------------------------------
## Operations: Accumulators (Ufuncs): minimum
ccs_accum_def('minimum', 'minimum',
	      decls          =>'$GENERIC(nzvalsIn) curval;',
	      init_missingOut=>'missingOut = missingVal;',
	      tmp_addmissing =>'if (nMissing > 0 && missingVal < tmp) { tmp = missingVal; }',
	      tmp_addval     =>'curval=$nzvalsIn(NnzIn=>nnzii); if (curval<tmp) tmp=curval;',
	      doc_addmissing => <<'EOMD',

If $N() is specified and greater than zero,
and if $missing() is less than any listed value for a vector key with a run-length
of less than $N(), then $missing() is used as the output value for that key.
This is probably What You Want.

EOMD
	     );

##--------------------------------------------------------------
## Operations: Accumulators (Ufuncs): NYI
pp_addpm(<<'EOPM');

=pod

=head2 Ufuncs not yet implemented

=over 4

=item extrema indices

maximum_ind, minimum_ind, ...

=item statistical aggregates

average, daverage, medover, oddmedover, pctover, ...

=item cumulative functions

cumusumover, cumuprodover, ...

=item other stuff

zcover, intover, minmaximum

=back

=cut

EOPM

##======================================================================
## Operations: Binary
##======================================================================
pp_addpm(<<'EOPM');

=pod

=head1 Binary Operations

=cut

EOPM

## IDEA:
##  ccs_binop_${OP}(int    ixa(NdimsA,NnzA),    nza(NnzA),    missinga(),
##                  int    ixb(NdimsB,NnzB),    nzb(NnzB),    missingb(),
##                  int [o]ixc(NdimsC,NnzC), [o]nzc(NnzC), [o]missingc())
##  + where:
##    - NdimsA==NdimsB==NdimsC  ##-- simple case: no (pseudo-)threading
##    - NnzC <= NnzA+NnzB       ##-- add auto-trimming in PMCode
##    - ixa() and ixb() are both sorted
##
##  + idea: basic algorithm
##    - traverse ixa(),ixb() in parallel (as for vv_union() & friends)
##    - dispatch at each position:
##      ~ CASE ixa(,ai) == ixb(,bi) : INSERT ( ixa(,ai) => ixa(,ai)   ${OP} ixb(,bi)   ); ai++; bi++;
##      ~ CASE ixa(,ai) <  ixb(,bi) : INSERT ( ixa(,ai) => ixa(,ai)   ${OP} missingb() ); ai++;
##      ~ CASE ixa(,ai) >  ixb(,bi) : INSERT ( ixb(,bi) => missinga() ${OP} ixb(,bi)   );       bi++;
##    - DO auto-detect "missingOut" values, e.g. add 'tmp_isgood' check
##
##  + extension: pseudo-threading
##    - idea: allow (NdimsA != NdimsB)
##      ~ generalize to highest order: set NdimsC = max(NdimsA,NdimsB)
##      ~ also allow PMCode to dispatch s.t. (NdimsB <= NdimsA)
##      ~ then, vector comparison is: ixa(0..(NdimsB-1),ai) <=> ixb(,bi)
##        * requires home-grown CMPVEC or extension of PDL::VectorValued $CMPVEC() macro
##        * this allows ixb() to thread over INITIAL dimensions (a la PDL threading)
##        * still doesn't generalize to VECTORS ~ dimension-mismatches where e.g. NdimsB(dimi)==1
##      ~ also wreaks havoc with the case-based increment strategy above:
##        * if (NdimsB < NdimsA), we might well have multiple matches on a single ixb(,bi)
##        * third insertion case may induce a dense matrix, b/c requires implicit iteration:
##             { insert( ixb(,bi) => missinga() ${OP} ixb(,bi) ); bi++ }
##          + this won't cut the sparse butter though, since ixb(,bi) ~= $ixb(,bi).cat_{di=1}^{NdimsA-NdimsB)(seq(di))
##      ~ maybe abstract "alignment" code (ixa(,ai)<=>ixb(,bi)) to its own function
##        and do the rest in perl?
##        * ccs_binop_align( ixa(), ixb(), int [o]ai(NnzC), int [o]bi(NnC) )
##          - here, we can use a constant (say, -1 or BAD) to indicate "no-match", e.g.
##              ai->isbad()   iff.   ixa(,ai) <  ixb(,bi)
##              bi->isbad()   iff.   ixa(,ai) >  ixb(,bi)
##          - maybe 'annihilator assumption' from compat vector-ops can save us ...

##======================================================================
## Footer Administrivia
##======================================================================

##------------------------------------------------------
## pm additions: footer
pp_addpm(<<'EOPM');

##---------------------------------------------------------------------
=pod

=head1 ACKNOWLEDGEMENTS

Perl by Larry Wall.

PDL by Karl Glazebrook, Tuomas J. Lukka, Christian Soeller, and others.

=cut

##----------------------------------------------------------------------
=pod

=head1 KNOWN BUGS

Probably many.

=cut


##---------------------------------------------------------------------
=pod

=head1 AUTHOR

Bryan Jurish E<lt>moocow@ling.uni-potsdam.deE<gt>

=head2 Copyright Policy

Copyright (C) 2007, Bryan Jurish. All rights reserved.

This package is free software, and entirely without warranty.
You may redistribute it and/or modify it under the same terms
as Perl itself.

=head1 SEE ALSO

perl(1), PDL(3perl)

=cut

EOPM


# Always make sure that you finish your PP declarations with
# pp_done
pp_done();
##----------------------------------------------------------------------
