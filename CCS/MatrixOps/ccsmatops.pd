##-*- Mode: CPerl -*-

##======================================================================
## Header Administrivia
##======================================================================

use PDL::VectorValued::Dev;
my $VERSION = '1.23.1'; ##-- update with perl-reversion from Perl::Version module
pp_setversion($VERSION);

##-- for integer-type keys
require "../Config.pm";
my $INT_TYPES = join('',@{$PDL::CCS::Config::ccsConfig{INT_TYPE_CHRS}});

##------------------------------------------------------
## pm headers
pp_addpm({At=>'Top'},<<'EOPM');

#use PDL::CCS::Version;
use strict;

=pod

=head1 NAME

PDL::CCS::MatrixOps - Low-level matrix operations for compressed storage sparse PDLs

=head1 SYNOPSIS

 use PDL;
 use PDL::CCS::MatrixOps;

 ##---------------------------------------------------------------------
 ## ... stuff happens

=cut

EOPM
## /pm additions
##------------------------------------------------------

##------------------------------------------------------
## Exports: None
#pp_export_nothing();

##------------------------------------------------------
## Includes / defines
pp_addhdr(<<'EOH');
#include <math.h> /*-- for NAN --*/
EOH

##------------------------------------------------------
## index datatype
require "../Config.pm";
our $INDX = $PDL::CCS::Config::ccsConfig{INDX_SIG};
pp_addpm( $PDL::CCS::Config::ccsConfig{INDX_FUNCDEF} );
pp_addhdr( $PDL::CCS::Config::ccsConfig{INDX_TYPEDEF} );


##======================================================================
## C Utilities
##======================================================================
# (none)

##======================================================================
## PDL::PP Wrappers
##======================================================================


##======================================================================
## Operations: matmult2d
##======================================================================

##--------------------------------------------------------------
vvpp_def
  ('ccs_matmult2d_sdd',
   Pars => ("\n    "
	    .join("\n    ",
		  "$INDX ixa(NdimsA,NnzA); nza(NnzA); missinga();", ## a(M,N) (M~i, N~x): formerly here as a(N,M)
		  'b(O,M);',                                      ## b(O,M) (O~z, M~i)
		  'zc(O);',                                       ## zc(O)
		  '[o]c(O,N)',                                    ## c(O,N) (O~z, N~x)
		  '')),
   Code =>
(q(
 //-- initialize: set output to $zc()
 loop (O) %{
   $GENERIC(zc) zc_o = $zc();
   loop (N) %{
     $c() = zc_o;
   %}
 %}
 //
 //-- main loop
 loop (NnzA) %{
   CCS_Indx mi = $ixa(NdimsA=>0);
   CCS_Indx ni = $ixa(NdimsA=>1);
   loop (O) %{
     //--# c(o,n) = sum for m=1 to M [a(m,n) * b(o,m)]
     $c(N=>ni) += $b(M=>mi) * ($nza() - $missinga());
   %}
 %}
)),
  Doc =>
(q{
Two-dimensional matrix multiplication of a sparse index-encoded PDL
$a() with a dense pdl $b(), with output to a dense pdl $c().

The sparse input PDL $a() should be passed here with 0th
dimension "M" and 1st dimension "N", just as for the
built-in PDL::Primitive::matmult().

"Missing" values in $a() are treated as $missinga(), which shouldn't
be BAD or infinite, but otherwise ought to be handled correctly.
The input pdl $zc() is used to pass the cached contribution of
a $missinga()-row ("M") to an output column ("O"), i.e.

 $zc = ((zeroes($M,1)+$missinga) x $b)->flat;

$SIZE(Ndimsa) is assumed to be 2.
}),
 ); ##--/ccs_matmult2d_sdd


##--------------------------------------------------------------
vvpp_def
  ('ccs_matmult2d_zdd',
   Pars => ("\n    "
	    .join("\n    ",
		  "$INDX ixa(Ndimsa,NnzA); nza(NnzA);", ## a(M,N) (M~i, N~x)
		  'b(O,M);',                          ## b(O,M) (O~z, M~i)
		  '[o]c(O,N)',                        ## c(O,N) (O~z, N~x)
		  '')),
   Code =>
(q(
 //-- initialize output to zero
 loop (N) %{
   loop (O) %{
     $c()=0;
   %}
 %}
 //
 //-- main loop over CCS-encoded a()
 loop (NnzA) %{
   CCS_Indx Mi = $ixa(Ndimsa=>0);
   CCS_Indx Ni = $ixa(Ndimsa=>1);
   loop (O) %{
     $c(N=>Ni) += $nza() * $b(M=>Mi);
   %}
 %}
)),
  Doc =>
(q{
Two-dimensional matrix multiplication of a sparse index-encoded PDL
$a() with a dense pdl $b(), with output to a dense pdl $c().

The sparse input PDL $a() should be passed here with 0th
dimension "M" and 1st dimension "N", just as for the
built-in PDL::Primitive::matmult().

"Missing" values in $a() are treated as zero.
$SIZE(Ndimsa) is assumed to be 2.
}),
 ); ##--/ccs_matmult2d_zdd


##--------------------------------------------------------------
## ccs_vcos_zdd
my $vcos_zdd_code =
'
    CCS_Indx an,am, bm;
    $GENERIC(anorm) bnorm;
    $GENERIC(nza)   av;
    int have_anorm = 0; /*-- avoid redundant re-computation of anorm() --*/

    /*-- sanity check: dimension "Two" --*/
    if ($SIZE(Two) != 2) {
       croak("ccs_vcos_zdd(): bogus input dimension Two=%ld for index-piddle ixa(Two,NnzA) must be 2", $SIZE(Two));
    }

    threadloop %{
      /*-- cache bnorm as \sum_{i=1}^d b[i]**2 --*/
      bnorm = 0;
      loop (N) %{
#ifdef PDL_BAD_CODE
	if ($ISGOOD(b()))
#endif
          bnorm += $b() * $b();
      %}
      bnorm = sqrt(bnorm);
      if (bnorm == 0) {
        /*-- pathological case: return all NaN --*/
        loop(M) %{ $vcos() = NAN; %}
      }
      else {
        /*-- initialize --*/
        loop (M) %{ $vcos() = 0; %}

        /*-- compute \sum_{i=1}^n (a[i]*b[i]) in vcos(), caching anorm=\sum_{i=1}^n a[i]**2 if appropriate --*/
	if (!have_anorm) {
          loop (M) %{ $anorm() = 0; %}
          loop (NnzA) %{
	    /*-- first nontrivial threadloop iteration: populate anorm() --*/
	    am = $ixa(Two=>0);
	    an = $ixa(Two=>1);
            av = $nza();
#ifdef PDL_BAD_CODE
            if ($ISGOOD(nza())) {
#endif
	      $anorm(M=>am) += av * av;
#ifdef PDL_BAD_CODE
              if ($ISGOOD(b(N=>an)))
#endif
	        $vcos(M=>am)  += av * $b(N=>an);
#ifdef PDL_BAD_CODE
            }
#endif
	  %}
          have_anorm = 1;
	} else {
	  loop (NnzA) %{
  	    /*-- non-initial threadloop iteration: we already have anorm() --*/
	    am = $ixa(Two=>0);
	    an = $ixa(Two=>1);
#ifdef PDL_BAD_CODE
            if ($ISGOOD(nza()) && $ISGOOD(b(N=>an)))
#endif
	      $vcos(M=>am) += $nza() * $b(N=>an);
	  %}
	}

        /*-- factor out vector magnitudes (Euclidean norms ||a||*||b||), cached in anorm, bnorm() --*/
        loop (M) %{
          if ($anorm() != 0) {
	    $vcos() /= (sqrt($anorm()) * bnorm);
	  } else {
            /*-- bogus anorm(), return NaN --*/
	    $vcos() = NAN;
	  }
        %}
      }
    %}
';

vvpp_def
  ('ccs_vcos_zdd',
   Pars => ("\n    "
	    .join("\n    ",
		  "$INDX ixa(Two,NnzA); nza(NnzA);",   ##-- logical (M,N)
		  "b(N);",		   	       ##-- logical (1,N)
		  "float+ [o]vcos(M);",
		  "float+ [t]anorm(M);",
		 )),
   OtherPars => "int sizeM=>M;",
   HandleBad => 1,
   Code=>$vcos_zdd_code,
   BadCode=>$vcos_zdd_code,
   CopyBadStatusCode=>
(q{
   if ( $ISPDLSTATEBAD(b) || $ISPDLSTATEBAD(nza) ) {
     $SETPDLSTATEBAD(vcos);
   }
}),
  Doc=>
(q{
Computes the vector cosine similarity of a dense row-vector $b(N) with respect to each column $a(i,*)
of a sparse index-encoded PDL $a() of logical dimensions (M,N), with output to a dense piddle
$vcos(M).  "Missing" values in $a() are treated as zero, and $SIZE(Two) must be 2.
This is basically the same thing as:

 ($a * $b->slice("*1,"))->xchg(0,1)->sumover / ($a->pow(2)->xchg(0,1)->sumover->sqrt * $b->pow(2)->sumover->sqrt)

... but should be must faster to compute.  Output values in $vcos() are cosine similarities in the range [-1,1],
except for zero-magnitude vectors which will result in NaN values in $vcos().
If you need non-negative distances, follow this up with a:

 $vcos->minus(1,$vcos,1)
 $vcos->inplace->setnantobad->inplace->setbadtoval(0); ##-- minimum distance for NaN values

to get distances values in the range [0,2].  You can use PDL threading to batch-compute distances for
multiple $b() vectors simultaneously:

  $bx   = random($N, $NB);                   ##-- get $NB random vectors of size $N
  $vcos = ccs_vcos_zdd($ixa,$nza, $bx, $M);  ##-- $vcos is now ($M,$NB)


}),
  BadDoc=>
(q{
ccs_vcos_zdd() will set the bad status flag on the output piddle $vcos() if it is set on either of the input
piddles $nza() or $b().
}),
  ); ##-- /ccs_vcos_zdd


##======================================================================
## Footer Administrivia
##======================================================================

##------------------------------------------------------
## pm additions: footer
pp_addpm(<<'EOPM');

##---------------------------------------------------------------------
=pod

=head1 ACKNOWLEDGEMENTS

Perl by Larry Wall.

PDL by Karl Glazebrook, Tuomas J. Lukka, Christian Soeller, and others.

=cut

##----------------------------------------------------------------------
=pod

=head1 KNOWN BUGS

We should really implement matrix multiplication in terms of
inner product, and have a good sparse-matrix only implementation
of the former.

=cut


##---------------------------------------------------------------------
=pod

=head1 AUTHOR

Bryan Jurish E<lt>moocow@cpan.orgE<gt>

=head2 Copyright Policy

All other parts Copyright (C) 2009-2015, Bryan Jurish. All rights reserved.

This package is free software, and entirely without warranty.
You may redistribute it and/or modify it under the same terms
as Perl itself.

=head1 SEE ALSO

perl(1), PDL(3perl)

=cut

EOPM


# Always make sure that you finish your PP declarations with
# pp_done
pp_done();
##----------------------------------------------------------------------
