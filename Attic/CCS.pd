#-*- Mode: Perl -*-

##======================================================================
## Header Administrivia
##======================================================================

our $VERSION = '0.02';
pp_setversion($VERSION);

##------------------------------------------------------
## pm additions
pp_addpm({At=>'Top'},<<'EOPM');
=pod

=head1 NAME

PDL::CCS - Compressed Column Storage for 2d PDLs

=head1 SYNOPSIS

 use PDL;
 use PDL::CCS;

 ##-- source pdl
 $a = random(8,7);

 ##-- number of nonzero elements
 $nnz  = $a->flat->nnz;
 $nnaz = $a->flat->nnza(1e-6);

 ##-- compressed column format encoding
 ($ptr,$rowids,$vals) = ccsencode($a);

 ##-- compressed column format decoding
 $a2 = ccsdecode($ptr,$rowids,$vals);

=cut

EOPM
## /pm additions
##------------------------------------------------------

##------------------------------------------------------
## Exports: None
pp_export_nothing();

##------------------------------------------------------
## Includes / defines
pp_addhdr(<<'EOH');
EOH


##======================================================================
## C Utilities
##======================================================================
# (none)


##======================================================================
## PDL::PP Wrappers
##======================================================================

##======================================================================
## Basic Utilities
#pp_addpm(<<'EOPM');
#=pod
#
#=head1 Basic Utilities
#
#=cut
#EOPM

##------------------------------------------------------
## nnz() : get number of nonzero values
pp_def('nnz',
       Pars => 'a(N); int [o]nnz()',
       Code =>
('
  $nnz()=0;
  loop (N) %{
    if ($a()!=0) ++$nnz();
  %}
'),
       Doc =>
q(Get number of non-zero elements in a PDL $a();
For 1d PDLs, should be equivalent to:

 $nnz = nelem(which($a!=0));

For k>1 dimensional PDLs, projects via number of nonzero elements
to N-1 dimensions by computing the number of nonzero elements
along the the 1st dimension.
),
      );

##------------------------------------------------------
## nnza() : get number of non-approximate zero values
pp_def('nnza',
       Pars => 'a(N); eps(); int [o]nnz()',
       Code => ('$nnz()=0; loop (N) %{ if (abs($a()) > $eps()) ++$nnz(); %}'),
       Doc =>
q(Like nnz() using tolerance constant $eps().
For 1d PDLs, should be equivalent to:

 $nnz = nelem(which(!$a->approx(0,$eps)));
),
      );

##------------------------------------------------------
## ccsencode() : encoding
pp_def('ccsencodefull',
       Pars => 'a(N,M); int [o]ptr(N); int [o]rowids(Nnz); [o]nzvals(Nnz)',
       Code =>
q(
  int nnzi=0;
  loop (N) %{
    $ptr() = nnzi;
    loop (M) %{
      if ($a()!=0) {
	$rowids(Nnz=>nnzi) = M;
	$nzvals(Nnz=>nnzi) = $a();
	++nnzi;
      }
    %}
  %}
),
       Doc =>
q(Encode 2d PDL $a() into compressed column format vectors
$ptr(), $rowids(), and $nzvals(), useful for storing large
sparse matrices.  The user is responsible for
allocating the output vectors $rowids() and $nzvals(),
which should be of length $Nnz, where $Nnz is the total
number of nonzero elements in $a().

The vector $nzvals() stores the actual nonzero values
of $a(), and the vector $rowids() stores the corresponding
row indices: $a(i,j)==$nzvals(k) implies j==$rowids(k),
for 0<=i<N, 0<=k<Nnz.  The vector $ptr() stores those
indices of $nzvals() which begin a new column:
$a(i,j)==$nzvals(k) implies $ptr(i)<=k<=$ptr(i+1).

See L<EXAMPLES> below for an example.
),
      );

##------------------------------------------------------
## ccsencodefulla() : encoding (approximate)
pp_def('ccsencodefulla',
       Pars => 'a(N,M); eps(); int [o]ptr(N); int [o]rowids(Nnz); [o]nzvals(Nnz)',
       Code =>
q(
  int nnzi=0;
  loop (N) %{
    $ptr() = nnzi;
    loop (M) %{
      if (abs($a()) > $eps()) {
	$rowids(Nnz=>nnzi) = M;
	$nzvals(Nnz=>nnzi) = $a();
	++nnzi;
      }
    %}
  %}
),
       Doc =>
q(Encode 2d PDL $a() in compressed column format (approximating).  This
method is just like ccsencodefull(), above, but uses the tolerance parameter
$eps() to determine which elements are to be treated as zeroes.
),
      );


##------------------------------------------------------
## _ccsdecode() : dencoding
pp_def('ccsdecodefull',
       Pars => 'int ptr(N); int rowids(Nnz); nzvals(Nnz); [o]dense(N,M)',
       Code =>
q(
  int ni, nnzimax, nnzi=$ptr(N=>0);
  for (ni=1; ni <= $SIZE(N); ni++) {
    int colid = ni-1;
    if (ni != $SIZE(N)) nnzimax = $ptr(N=>ni);
    else                nnzimax = $SIZE(Nnz);
    for (; nnzi < nnzimax; nnzi++) {
      int rowid = $rowids(Nnz=>nnzi);
      $dense(N=>colid, M=>rowid) = $nzvals(Nnz=>nnzi);
    }
  }
),
       Doc =>
q(Decode compressed column vectors $ptr(), $rowids(), and $nzvals() into
dense 2d matrix $dense().  The user is responsible for allocating
$dense().
),
      );


##======================================================================
## Convenience Methods

##------------------------------------------------------
## ccsencode() : encoding (convenience)
pp_add_exported('','ccsencode');
pp_addpm(<<'EOPM');

=pod

=head2 ccsencode

=for sig

  Signature: (a(N,M); int [o]ptr(N); int [o]rowids(Nnz); [o]nzvals(Nnz))

Convenience method.
Encodes matrix $a() in compressed column format
by calling ccsencodefull(), allocating output
vectors if required.

=cut

sub ccsencode {
  my ($a,$ptr,$rowids,$nzvals)=@_;
  $ptr=zeroes(long,$a->dim(0)) if (!defined($ptr));
  my ($nnz);
  if (defined($rowids)) {
    $nnz = $rowids->nelem;
    $nzvals = zeroes($a->type,$nnz) if (!defined($nzvals));
  } else {
    $nnz = $a->flat->nnz;
    $rowids = zeroes(long,$nnz);
    $nzvals = zeroes($a->type,$nnz);
  }
  ccsencodefull($a,$ptr,$rowids,$nzvals);
  return ($ptr,$rowids,$nzvals);
}

EOPM

##------------------------------------------------------
## ccsencodea() : encoding +approximation (convenience)
pp_add_exported('','ccsencodea');
pp_addpm(<<'EOPM');

=pod

=head2 ccsencodea

=for sig

  Signature: (a(N,M); eps(); int [o]ptr(N); int [o]rowids(Nnz); [o]nzvals(Nnz))

Convenience method.
Encodes matrix $a() in compressed column format
by calling ccsencodefulla(),
allocating output
vectors if required.

=cut

sub ccsencodea {
  my ($a,$eps,$ptr,$rowids,$nzvals)=@_;
  $eps = 1e-6 if (!defined($eps));
  $ptr = zeroes(long,$a->dim(0)) if (!defined($ptr));
  my ($nnz);
  if (defined($rowids)) {
    $nnz = $rowids->nelem;
    $nzvals = zeroes($a->type,$nnz) if (!defined($nzvals));
  } else {
    $nnz = $a->flat->nnza($eps);
    $rowids = zeroes(long,$nnz);
    $nzvals = zeroes($a->type,$nnz);
  }
  ccsencodefulla($a,$eps,$ptr,$rowids,$nzvals);
  return ($ptr,$rowids,$nzvals);
}

EOPM

##------------------------------------------------------
## ccdencode() : decoding (convenience)
pp_add_exported('','ccsdecode');
pp_addpm(<<'EOPM');

=pod

=head2 ccsdecode

=for sig

  Signature: (int ptr(N); int rowids(Nnz); nzvals(Nnz); [o]dense(N,M))

Convenience method.
Decodes compressed column format vectors $ptr(), $rowids(), and $nzvals()
into dense output matrix $a() by calling ccsdecodefull(),
allocating output matrix if required.  Note that if the original
matrix (pre-encoding) contained trailing rows with no nonzero elements,
such rows will not be allocated by this method -- in this case,
you should prefer ccsdecodefull().

=cut

sub ccsdecode {
  my ($ptr,$rowids,$nzvals,$dense)=@_;
  if (!defined($dense)) {
    my $M = $rowids->max+1;
    $dense = zeroes(double,$ptr->dim(0),$M);
  }
  ccsdecodefull($ptr,$rowids,$nzvals,$dense);
  return $dense;
}

=cut

EOPM


##======================================================================
## Footer Administrivia
##======================================================================

##------------------------------------------------------
## pm additions
pp_addpm(<<'EOPM');

##---------------------------------------------------------------------
=pod

=head1 EXAMPLES

=head2 Compressed Column Format Example

 $a = pdl([
	   [10, 0, 0, 0,-2,  0],
	   [3,  9, 0, 0, 0,  3],
	   [0,  7, 8, 7, 0,  0],
	   [3,  0, 8, 7, 5,  0],
	   [0,  8, 0, 9, 9, 13],
	   [0,  4, 0, 0, 2, -1]
	  ]);

 ($ptr,$rowids,$nzvals) = ccsencode($a);

 print join("\n", "ptr=$p", "rowids=$rowids", "nzvals=$nzvals");

... prints something like:

 ptr=[0 3 7 9 12 16]
 rowids=[ 0 1 3 1 2 4 5 2 3 2 3 4  0 3 4 5 1  4  5]
 nzvals=[10 3 3 9 7 8 4 8 8 7 7 9 -2 5 9 2 3 13 -1]


=head2 Sparse Matrix Example

 ##-- create a random sparse matrix
 $a  = random(100,100);
 $a *= ($a>.9);

 ##-- encode it
 ($ptr,$rowids,$nzvals) = ccsencode($a);

 ##-- what did we save?
 sub pdlsize { return PDL::howbig($_[0]->type)*$_[0]->nelem; }
 print "Encoding saves us ",
       ($saved = pdlsize($a) - pdlsize($ptr) - pdlsize($rowids) - pdlsize($nzvals)),
       " bytes (", (100.0*$saved/pdlsize($a)), "%)\n";

... prints something like:

 Encoding saves us 71416 bytes (89.27%)



=head2 Decoding Example

 ##-- random matrix
 $a = random(100,100);

 ##-- make an expensive copy of $a by encoding & decoding
 ($ptr,$rowids,$nzvals) = ccsencode($a);
 $a2 = ccsdecode($ptr,$rowids,$nzvals);

 ##-- ...and make sure it's good
 print all($a==$a2) ? "Decoding is good!\n" : "Nasty icky bug!\n";

=cut

##---------------------------------------------------------------------
=pod

=head1 ACKNOWLEDGEMENTS

Perl by Larry Wall.

PDL by Karl Glazebrook, Tuomas J. Lukka, Christian Soeller, and others.

=cut

##----------------------------------------------------------------------
=pod

=head1 KNOWN BUGS

Probably many.

=cut


##---------------------------------------------------------------------
=pod

=head1 AUTHOR

Bryan Jurish E<lt>moocow@ling.uni-potsdam.deE<gt>

=head2 Copyright Policy

Copyright (C) 2005, Bryan Jurish. All rights reserved.

This package is free software, and entirely without warranty.
You may redistribute it and/or modify it under the same terms
as Perl itself.

=head1 SEE ALSO

perl(1), PDL(3perl).

=cut

EOPM


# Always make sure that you finish your PP declarations with
# pp_done
pp_done();
##----------------------------------------------------------------------
